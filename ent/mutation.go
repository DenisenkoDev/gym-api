// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"gym-api/ent/abonement"
	"gym-api/ent/abonementtype"
	"gym-api/ent/credential"
	"gym-api/ent/gym"
	"gym-api/ent/managerrole"
	"gym-api/ent/payment"
	"gym-api/ent/paymentrequisite"
	"gym-api/ent/predicate"
	"gym-api/ent/usagemode"
	"gym-api/ent/user"
	"gym-api/ent/userrole"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbonement        = "Abonement"
	TypeAbonementType    = "AbonementType"
	TypeCredential       = "Credential"
	TypeGym              = "Gym"
	TypeManagerRole      = "ManagerRole"
	TypePayment          = "Payment"
	TypePaymentRequisite = "PaymentRequisite"
	TypeUsageMode        = "UsageMode"
	TypeUser             = "User"
	TypeUserRole         = "UserRole"
)

// AbonementMutation represents an operation that mutates the Abonement nodes in the graph.
type AbonementMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	price              *float64
	addprice           *float64
	duration_months    *int
	addduration_months *int
	expiration_date    *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	paid_until         *time.Time
	is_active          *bool
	is_paid            *bool
	clearedFields      map[string]struct{}
	payments           map[int]struct{}
	removedpayments    map[int]struct{}
	clearedpayments    bool
	user               *int
	cleareduser        bool
	coach              *int
	clearedcoach       bool
	gym                *int
	clearedgym         bool
	_type              *int
	cleared_type       bool
	done               bool
	oldValue           func(context.Context) (*Abonement, error)
	predicates         []predicate.Abonement
}

var _ ent.Mutation = (*AbonementMutation)(nil)

// abonementOption allows management of the mutation configuration using functional options.
type abonementOption func(*AbonementMutation)

// newAbonementMutation creates new mutation for the Abonement entity.
func newAbonementMutation(c config, op Op, opts ...abonementOption) *AbonementMutation {
	m := &AbonementMutation{
		config:        c,
		op:            op,
		typ:           TypeAbonement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbonementID sets the ID field of the mutation.
func withAbonementID(id int) abonementOption {
	return func(m *AbonementMutation) {
		var (
			err   error
			once  sync.Once
			value *Abonement
		)
		m.oldValue = func(ctx context.Context) (*Abonement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Abonement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbonement sets the old Abonement of the mutation.
func withAbonement(node *Abonement) abonementOption {
	return func(m *AbonementMutation) {
		m.oldValue = func(context.Context) (*Abonement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbonementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbonementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbonementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AbonementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Abonement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AbonementMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AbonementMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AbonementMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *AbonementMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *AbonementMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *AbonementMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *AbonementMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *AbonementMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDurationMonths sets the "duration_months" field.
func (m *AbonementMutation) SetDurationMonths(i int) {
	m.duration_months = &i
	m.addduration_months = nil
}

// DurationMonths returns the value of the "duration_months" field in the mutation.
func (m *AbonementMutation) DurationMonths() (r int, exists bool) {
	v := m.duration_months
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMonths returns the old "duration_months" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldDurationMonths(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMonths: %w", err)
	}
	return oldValue.DurationMonths, nil
}

// AddDurationMonths adds i to the "duration_months" field.
func (m *AbonementMutation) AddDurationMonths(i int) {
	if m.addduration_months != nil {
		*m.addduration_months += i
	} else {
		m.addduration_months = &i
	}
}

// AddedDurationMonths returns the value that was added to the "duration_months" field in this mutation.
func (m *AbonementMutation) AddedDurationMonths() (r int, exists bool) {
	v := m.addduration_months
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMonths resets all changes to the "duration_months" field.
func (m *AbonementMutation) ResetDurationMonths() {
	m.duration_months = nil
	m.addduration_months = nil
}

// SetExpirationDate sets the "expiration_date" field.
func (m *AbonementMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *AbonementMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *AbonementMutation) ResetExpirationDate() {
	m.expiration_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AbonementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AbonementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AbonementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AbonementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AbonementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AbonementMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[abonement.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AbonementMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[abonement.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AbonementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, abonement.FieldUpdatedAt)
}

// SetPaidUntil sets the "paid_until" field.
func (m *AbonementMutation) SetPaidUntil(t time.Time) {
	m.paid_until = &t
}

// PaidUntil returns the value of the "paid_until" field in the mutation.
func (m *AbonementMutation) PaidUntil() (r time.Time, exists bool) {
	v := m.paid_until
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidUntil returns the old "paid_until" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldPaidUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidUntil: %w", err)
	}
	return oldValue.PaidUntil, nil
}

// ClearPaidUntil clears the value of the "paid_until" field.
func (m *AbonementMutation) ClearPaidUntil() {
	m.paid_until = nil
	m.clearedFields[abonement.FieldPaidUntil] = struct{}{}
}

// PaidUntilCleared returns if the "paid_until" field was cleared in this mutation.
func (m *AbonementMutation) PaidUntilCleared() bool {
	_, ok := m.clearedFields[abonement.FieldPaidUntil]
	return ok
}

// ResetPaidUntil resets all changes to the "paid_until" field.
func (m *AbonementMutation) ResetPaidUntil() {
	m.paid_until = nil
	delete(m.clearedFields, abonement.FieldPaidUntil)
}

// SetIsActive sets the "is_active" field.
func (m *AbonementMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AbonementMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AbonementMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsPaid sets the "is_paid" field.
func (m *AbonementMutation) SetIsPaid(b bool) {
	m.is_paid = &b
}

// IsPaid returns the value of the "is_paid" field in the mutation.
func (m *AbonementMutation) IsPaid() (r bool, exists bool) {
	v := m.is_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPaid returns the old "is_paid" field's value of the Abonement entity.
// If the Abonement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementMutation) OldIsPaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPaid: %w", err)
	}
	return oldValue.IsPaid, nil
}

// ResetIsPaid resets all changes to the "is_paid" field.
func (m *AbonementMutation) ResetIsPaid() {
	m.is_paid = nil
}

// AddPaymentIDs adds the "payments" edge to the Payment entity by ids.
func (m *AbonementMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the Payment entity.
func (m *AbonementMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the Payment entity was cleared.
func (m *AbonementMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the Payment entity by IDs.
func (m *AbonementMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the Payment entity.
func (m *AbonementMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *AbonementMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *AbonementMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AbonementMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AbonementMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AbonementMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AbonementMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AbonementMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AbonementMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCoachID sets the "coach" edge to the User entity by id.
func (m *AbonementMutation) SetCoachID(id int) {
	m.coach = &id
}

// ClearCoach clears the "coach" edge to the User entity.
func (m *AbonementMutation) ClearCoach() {
	m.clearedcoach = true
}

// CoachCleared reports if the "coach" edge to the User entity was cleared.
func (m *AbonementMutation) CoachCleared() bool {
	return m.clearedcoach
}

// CoachID returns the "coach" edge ID in the mutation.
func (m *AbonementMutation) CoachID() (id int, exists bool) {
	if m.coach != nil {
		return *m.coach, true
	}
	return
}

// CoachIDs returns the "coach" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoachID instead. It exists only for internal usage by the builders.
func (m *AbonementMutation) CoachIDs() (ids []int) {
	if id := m.coach; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoach resets all changes to the "coach" edge.
func (m *AbonementMutation) ResetCoach() {
	m.coach = nil
	m.clearedcoach = false
}

// SetGymID sets the "gym" edge to the Gym entity by id.
func (m *AbonementMutation) SetGymID(id int) {
	m.gym = &id
}

// ClearGym clears the "gym" edge to the Gym entity.
func (m *AbonementMutation) ClearGym() {
	m.clearedgym = true
}

// GymCleared reports if the "gym" edge to the Gym entity was cleared.
func (m *AbonementMutation) GymCleared() bool {
	return m.clearedgym
}

// GymID returns the "gym" edge ID in the mutation.
func (m *AbonementMutation) GymID() (id int, exists bool) {
	if m.gym != nil {
		return *m.gym, true
	}
	return
}

// GymIDs returns the "gym" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GymID instead. It exists only for internal usage by the builders.
func (m *AbonementMutation) GymIDs() (ids []int) {
	if id := m.gym; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGym resets all changes to the "gym" edge.
func (m *AbonementMutation) ResetGym() {
	m.gym = nil
	m.clearedgym = false
}

// SetTypeID sets the "type" edge to the AbonementType entity by id.
func (m *AbonementMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the AbonementType entity.
func (m *AbonementMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared reports if the "type" edge to the AbonementType entity was cleared.
func (m *AbonementMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *AbonementMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *AbonementMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *AbonementMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Where appends a list predicates to the AbonementMutation builder.
func (m *AbonementMutation) Where(ps ...predicate.Abonement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbonementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbonementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Abonement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbonementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbonementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Abonement).
func (m *AbonementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbonementMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, abonement.FieldName)
	}
	if m.price != nil {
		fields = append(fields, abonement.FieldPrice)
	}
	if m.duration_months != nil {
		fields = append(fields, abonement.FieldDurationMonths)
	}
	if m.expiration_date != nil {
		fields = append(fields, abonement.FieldExpirationDate)
	}
	if m.created_at != nil {
		fields = append(fields, abonement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, abonement.FieldUpdatedAt)
	}
	if m.paid_until != nil {
		fields = append(fields, abonement.FieldPaidUntil)
	}
	if m.is_active != nil {
		fields = append(fields, abonement.FieldIsActive)
	}
	if m.is_paid != nil {
		fields = append(fields, abonement.FieldIsPaid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbonementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abonement.FieldName:
		return m.Name()
	case abonement.FieldPrice:
		return m.Price()
	case abonement.FieldDurationMonths:
		return m.DurationMonths()
	case abonement.FieldExpirationDate:
		return m.ExpirationDate()
	case abonement.FieldCreatedAt:
		return m.CreatedAt()
	case abonement.FieldUpdatedAt:
		return m.UpdatedAt()
	case abonement.FieldPaidUntil:
		return m.PaidUntil()
	case abonement.FieldIsActive:
		return m.IsActive()
	case abonement.FieldIsPaid:
		return m.IsPaid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbonementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abonement.FieldName:
		return m.OldName(ctx)
	case abonement.FieldPrice:
		return m.OldPrice(ctx)
	case abonement.FieldDurationMonths:
		return m.OldDurationMonths(ctx)
	case abonement.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	case abonement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case abonement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case abonement.FieldPaidUntil:
		return m.OldPaidUntil(ctx)
	case abonement.FieldIsActive:
		return m.OldIsActive(ctx)
	case abonement.FieldIsPaid:
		return m.OldIsPaid(ctx)
	}
	return nil, fmt.Errorf("unknown Abonement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbonementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abonement.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abonement.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case abonement.FieldDurationMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMonths(v)
		return nil
	case abonement.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	case abonement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case abonement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case abonement.FieldPaidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidUntil(v)
		return nil
	case abonement.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case abonement.FieldIsPaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPaid(v)
		return nil
	}
	return fmt.Errorf("unknown Abonement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbonementMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, abonement.FieldPrice)
	}
	if m.addduration_months != nil {
		fields = append(fields, abonement.FieldDurationMonths)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbonementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abonement.FieldPrice:
		return m.AddedPrice()
	case abonement.FieldDurationMonths:
		return m.AddedDurationMonths()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbonementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abonement.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case abonement.FieldDurationMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMonths(v)
		return nil
	}
	return fmt.Errorf("unknown Abonement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbonementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(abonement.FieldUpdatedAt) {
		fields = append(fields, abonement.FieldUpdatedAt)
	}
	if m.FieldCleared(abonement.FieldPaidUntil) {
		fields = append(fields, abonement.FieldPaidUntil)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbonementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbonementMutation) ClearField(name string) error {
	switch name {
	case abonement.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case abonement.FieldPaidUntil:
		m.ClearPaidUntil()
		return nil
	}
	return fmt.Errorf("unknown Abonement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbonementMutation) ResetField(name string) error {
	switch name {
	case abonement.FieldName:
		m.ResetName()
		return nil
	case abonement.FieldPrice:
		m.ResetPrice()
		return nil
	case abonement.FieldDurationMonths:
		m.ResetDurationMonths()
		return nil
	case abonement.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	case abonement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case abonement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case abonement.FieldPaidUntil:
		m.ResetPaidUntil()
		return nil
	case abonement.FieldIsActive:
		m.ResetIsActive()
		return nil
	case abonement.FieldIsPaid:
		m.ResetIsPaid()
		return nil
	}
	return fmt.Errorf("unknown Abonement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbonementMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.payments != nil {
		edges = append(edges, abonement.EdgePayments)
	}
	if m.user != nil {
		edges = append(edges, abonement.EdgeUser)
	}
	if m.coach != nil {
		edges = append(edges, abonement.EdgeCoach)
	}
	if m.gym != nil {
		edges = append(edges, abonement.EdgeGym)
	}
	if m._type != nil {
		edges = append(edges, abonement.EdgeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbonementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abonement.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	case abonement.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case abonement.EdgeCoach:
		if id := m.coach; id != nil {
			return []ent.Value{*id}
		}
	case abonement.EdgeGym:
		if id := m.gym; id != nil {
			return []ent.Value{*id}
		}
	case abonement.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbonementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpayments != nil {
		edges = append(edges, abonement.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbonementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abonement.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbonementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpayments {
		edges = append(edges, abonement.EdgePayments)
	}
	if m.cleareduser {
		edges = append(edges, abonement.EdgeUser)
	}
	if m.clearedcoach {
		edges = append(edges, abonement.EdgeCoach)
	}
	if m.clearedgym {
		edges = append(edges, abonement.EdgeGym)
	}
	if m.cleared_type {
		edges = append(edges, abonement.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbonementMutation) EdgeCleared(name string) bool {
	switch name {
	case abonement.EdgePayments:
		return m.clearedpayments
	case abonement.EdgeUser:
		return m.cleareduser
	case abonement.EdgeCoach:
		return m.clearedcoach
	case abonement.EdgeGym:
		return m.clearedgym
	case abonement.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbonementMutation) ClearEdge(name string) error {
	switch name {
	case abonement.EdgeUser:
		m.ClearUser()
		return nil
	case abonement.EdgeCoach:
		m.ClearCoach()
		return nil
	case abonement.EdgeGym:
		m.ClearGym()
		return nil
	case abonement.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Abonement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbonementMutation) ResetEdge(name string) error {
	switch name {
	case abonement.EdgePayments:
		m.ResetPayments()
		return nil
	case abonement.EdgeUser:
		m.ResetUser()
		return nil
	case abonement.EdgeCoach:
		m.ResetCoach()
		return nil
	case abonement.EdgeGym:
		m.ResetGym()
		return nil
	case abonement.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Abonement edge %s", name)
}

// AbonementTypeMutation represents an operation that mutates the AbonementType nodes in the graph.
type AbonementTypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	gym              *int
	clearedgym       bool
	abonement        map[int]struct{}
	removedabonement map[int]struct{}
	clearedabonement bool
	done             bool
	oldValue         func(context.Context) (*AbonementType, error)
	predicates       []predicate.AbonementType
}

var _ ent.Mutation = (*AbonementTypeMutation)(nil)

// abonementtypeOption allows management of the mutation configuration using functional options.
type abonementtypeOption func(*AbonementTypeMutation)

// newAbonementTypeMutation creates new mutation for the AbonementType entity.
func newAbonementTypeMutation(c config, op Op, opts ...abonementtypeOption) *AbonementTypeMutation {
	m := &AbonementTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAbonementType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbonementTypeID sets the ID field of the mutation.
func withAbonementTypeID(id int) abonementtypeOption {
	return func(m *AbonementTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AbonementType
		)
		m.oldValue = func(ctx context.Context) (*AbonementType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbonementType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbonementType sets the old AbonementType of the mutation.
func withAbonementType(node *AbonementType) abonementtypeOption {
	return func(m *AbonementTypeMutation) {
		m.oldValue = func(context.Context) (*AbonementType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbonementTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbonementTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbonementTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AbonementTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AbonementType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AbonementTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AbonementTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AbonementType entity.
// If the AbonementType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AbonementTypeMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AbonementTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AbonementTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AbonementType entity.
// If the AbonementType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbonementTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AbonementTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetGymID sets the "gym" edge to the Gym entity by id.
func (m *AbonementTypeMutation) SetGymID(id int) {
	m.gym = &id
}

// ClearGym clears the "gym" edge to the Gym entity.
func (m *AbonementTypeMutation) ClearGym() {
	m.clearedgym = true
}

// GymCleared reports if the "gym" edge to the Gym entity was cleared.
func (m *AbonementTypeMutation) GymCleared() bool {
	return m.clearedgym
}

// GymID returns the "gym" edge ID in the mutation.
func (m *AbonementTypeMutation) GymID() (id int, exists bool) {
	if m.gym != nil {
		return *m.gym, true
	}
	return
}

// GymIDs returns the "gym" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GymID instead. It exists only for internal usage by the builders.
func (m *AbonementTypeMutation) GymIDs() (ids []int) {
	if id := m.gym; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGym resets all changes to the "gym" edge.
func (m *AbonementTypeMutation) ResetGym() {
	m.gym = nil
	m.clearedgym = false
}

// AddAbonementIDs adds the "abonement" edge to the Abonement entity by ids.
func (m *AbonementTypeMutation) AddAbonementIDs(ids ...int) {
	if m.abonement == nil {
		m.abonement = make(map[int]struct{})
	}
	for i := range ids {
		m.abonement[ids[i]] = struct{}{}
	}
}

// ClearAbonement clears the "abonement" edge to the Abonement entity.
func (m *AbonementTypeMutation) ClearAbonement() {
	m.clearedabonement = true
}

// AbonementCleared reports if the "abonement" edge to the Abonement entity was cleared.
func (m *AbonementTypeMutation) AbonementCleared() bool {
	return m.clearedabonement
}

// RemoveAbonementIDs removes the "abonement" edge to the Abonement entity by IDs.
func (m *AbonementTypeMutation) RemoveAbonementIDs(ids ...int) {
	if m.removedabonement == nil {
		m.removedabonement = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.abonement, ids[i])
		m.removedabonement[ids[i]] = struct{}{}
	}
}

// RemovedAbonement returns the removed IDs of the "abonement" edge to the Abonement entity.
func (m *AbonementTypeMutation) RemovedAbonementIDs() (ids []int) {
	for id := range m.removedabonement {
		ids = append(ids, id)
	}
	return
}

// AbonementIDs returns the "abonement" edge IDs in the mutation.
func (m *AbonementTypeMutation) AbonementIDs() (ids []int) {
	for id := range m.abonement {
		ids = append(ids, id)
	}
	return
}

// ResetAbonement resets all changes to the "abonement" edge.
func (m *AbonementTypeMutation) ResetAbonement() {
	m.abonement = nil
	m.clearedabonement = false
	m.removedabonement = nil
}

// Where appends a list predicates to the AbonementTypeMutation builder.
func (m *AbonementTypeMutation) Where(ps ...predicate.AbonementType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbonementTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbonementTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AbonementType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbonementTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbonementTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AbonementType).
func (m *AbonementTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbonementTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, abonementtype.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, abonementtype.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbonementTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abonementtype.FieldName:
		return m.Name()
	case abonementtype.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbonementTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abonementtype.FieldName:
		return m.OldName(ctx)
	case abonementtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AbonementType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbonementTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abonementtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abonementtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AbonementType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbonementTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbonementTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbonementTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AbonementType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbonementTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbonementTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbonementTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AbonementType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbonementTypeMutation) ResetField(name string) error {
	switch name {
	case abonementtype.FieldName:
		m.ResetName()
		return nil
	case abonementtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AbonementType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbonementTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.gym != nil {
		edges = append(edges, abonementtype.EdgeGym)
	}
	if m.abonement != nil {
		edges = append(edges, abonementtype.EdgeAbonement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbonementTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abonementtype.EdgeGym:
		if id := m.gym; id != nil {
			return []ent.Value{*id}
		}
	case abonementtype.EdgeAbonement:
		ids := make([]ent.Value, 0, len(m.abonement))
		for id := range m.abonement {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbonementTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedabonement != nil {
		edges = append(edges, abonementtype.EdgeAbonement)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbonementTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abonementtype.EdgeAbonement:
		ids := make([]ent.Value, 0, len(m.removedabonement))
		for id := range m.removedabonement {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbonementTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgym {
		edges = append(edges, abonementtype.EdgeGym)
	}
	if m.clearedabonement {
		edges = append(edges, abonementtype.EdgeAbonement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbonementTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case abonementtype.EdgeGym:
		return m.clearedgym
	case abonementtype.EdgeAbonement:
		return m.clearedabonement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbonementTypeMutation) ClearEdge(name string) error {
	switch name {
	case abonementtype.EdgeGym:
		m.ClearGym()
		return nil
	}
	return fmt.Errorf("unknown AbonementType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbonementTypeMutation) ResetEdge(name string) error {
	switch name {
	case abonementtype.EdgeGym:
		m.ResetGym()
		return nil
	case abonementtype.EdgeAbonement:
		m.ResetAbonement()
		return nil
	}
	return fmt.Errorf("unknown AbonementType edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	password_hash *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Credential, error)
	predicates    []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPasswordHash sets the "password_hash" field.
func (m *CredentialMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *CredentialMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *CredentialMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CredentialMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CredentialMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CredentialMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.password_hash != nil {
		fields = append(fields, credential.FieldPasswordHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldPasswordHash:
		return m.PasswordHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// GymMutation represents an operation that mutates the Gym nodes in the graph.
type GymMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	currency_id              *int
	addcurrency_id           *int
	phone                    *string
	mail                     *string
	address                  *string
	web_site                 *string
	description              *string
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	visitors                 map[int]struct{}
	removedvisitors          map[int]struct{}
	clearedvisitors          bool
	managers                 map[int]struct{}
	removedmanagers          map[int]struct{}
	clearedmanagers          bool
	abonement_type           map[int]struct{}
	removedabonement_type    map[int]struct{}
	clearedabonement_type    bool
	owner                    *int
	clearedowner             bool
	abonements               map[int]struct{}
	removedabonements        map[int]struct{}
	clearedabonements        bool
	user_roles               map[int]struct{}
	removeduser_roles        map[int]struct{}
	cleareduser_roles        bool
	manager_roles            map[int]struct{}
	removedmanager_roles     map[int]struct{}
	clearedmanager_roles     bool
	payment_requisite        *int
	clearedpayment_requisite bool
	done                     bool
	oldValue                 func(context.Context) (*Gym, error)
	predicates               []predicate.Gym
}

var _ ent.Mutation = (*GymMutation)(nil)

// gymOption allows management of the mutation configuration using functional options.
type gymOption func(*GymMutation)

// newGymMutation creates new mutation for the Gym entity.
func newGymMutation(c config, op Op, opts ...gymOption) *GymMutation {
	m := &GymMutation{
		config:        c,
		op:            op,
		typ:           TypeGym,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGymID sets the ID field of the mutation.
func withGymID(id int) gymOption {
	return func(m *GymMutation) {
		var (
			err   error
			once  sync.Once
			value *Gym
		)
		m.oldValue = func(ctx context.Context) (*Gym, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gym.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGym sets the old Gym of the mutation.
func withGym(node *Gym) gymOption {
	return func(m *GymMutation) {
		m.oldValue = func(context.Context) (*Gym, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GymMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GymMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GymMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GymMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Gym.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GymMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GymMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GymMutation) ResetName() {
	m.name = nil
}

// SetCurrencyID sets the "currency_id" field.
func (m *GymMutation) SetCurrencyID(i int) {
	m.currency_id = &i
	m.addcurrency_id = nil
}

// CurrencyID returns the value of the "currency_id" field in the mutation.
func (m *GymMutation) CurrencyID() (r int, exists bool) {
	v := m.currency_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyID returns the old "currency_id" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyID: %w", err)
	}
	return oldValue.CurrencyID, nil
}

// AddCurrencyID adds i to the "currency_id" field.
func (m *GymMutation) AddCurrencyID(i int) {
	if m.addcurrency_id != nil {
		*m.addcurrency_id += i
	} else {
		m.addcurrency_id = &i
	}
}

// AddedCurrencyID returns the value that was added to the "currency_id" field in this mutation.
func (m *GymMutation) AddedCurrencyID() (r int, exists bool) {
	v := m.addcurrency_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrencyID resets all changes to the "currency_id" field.
func (m *GymMutation) ResetCurrencyID() {
	m.currency_id = nil
	m.addcurrency_id = nil
}

// SetPhone sets the "phone" field.
func (m *GymMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *GymMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *GymMutation) ResetPhone() {
	m.phone = nil
}

// SetMail sets the "mail" field.
func (m *GymMutation) SetMail(s string) {
	m.mail = &s
}

// Mail returns the value of the "mail" field in the mutation.
func (m *GymMutation) Mail() (r string, exists bool) {
	v := m.mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "mail" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ResetMail resets all changes to the "mail" field.
func (m *GymMutation) ResetMail() {
	m.mail = nil
}

// SetAddress sets the "address" field.
func (m *GymMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *GymMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *GymMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[gym.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *GymMutation) AddressCleared() bool {
	_, ok := m.clearedFields[gym.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *GymMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, gym.FieldAddress)
}

// SetWebSite sets the "web_site" field.
func (m *GymMutation) SetWebSite(s string) {
	m.web_site = &s
}

// WebSite returns the value of the "web_site" field in the mutation.
func (m *GymMutation) WebSite() (r string, exists bool) {
	v := m.web_site
	if v == nil {
		return
	}
	return *v, true
}

// OldWebSite returns the old "web_site" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldWebSite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebSite: %w", err)
	}
	return oldValue.WebSite, nil
}

// ClearWebSite clears the value of the "web_site" field.
func (m *GymMutation) ClearWebSite() {
	m.web_site = nil
	m.clearedFields[gym.FieldWebSite] = struct{}{}
}

// WebSiteCleared returns if the "web_site" field was cleared in this mutation.
func (m *GymMutation) WebSiteCleared() bool {
	_, ok := m.clearedFields[gym.FieldWebSite]
	return ok
}

// ResetWebSite resets all changes to the "web_site" field.
func (m *GymMutation) ResetWebSite() {
	m.web_site = nil
	delete(m.clearedFields, gym.FieldWebSite)
}

// SetDescription sets the "description" field.
func (m *GymMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GymMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GymMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[gym.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GymMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[gym.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GymMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, gym.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *GymMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GymMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GymMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GymMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GymMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Gym entity.
// If the Gym object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GymMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GymMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[gym.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GymMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[gym.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GymMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, gym.FieldUpdatedAt)
}

// AddVisitorIDs adds the "visitors" edge to the User entity by ids.
func (m *GymMutation) AddVisitorIDs(ids ...int) {
	if m.visitors == nil {
		m.visitors = make(map[int]struct{})
	}
	for i := range ids {
		m.visitors[ids[i]] = struct{}{}
	}
}

// ClearVisitors clears the "visitors" edge to the User entity.
func (m *GymMutation) ClearVisitors() {
	m.clearedvisitors = true
}

// VisitorsCleared reports if the "visitors" edge to the User entity was cleared.
func (m *GymMutation) VisitorsCleared() bool {
	return m.clearedvisitors
}

// RemoveVisitorIDs removes the "visitors" edge to the User entity by IDs.
func (m *GymMutation) RemoveVisitorIDs(ids ...int) {
	if m.removedvisitors == nil {
		m.removedvisitors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.visitors, ids[i])
		m.removedvisitors[ids[i]] = struct{}{}
	}
}

// RemovedVisitors returns the removed IDs of the "visitors" edge to the User entity.
func (m *GymMutation) RemovedVisitorsIDs() (ids []int) {
	for id := range m.removedvisitors {
		ids = append(ids, id)
	}
	return
}

// VisitorsIDs returns the "visitors" edge IDs in the mutation.
func (m *GymMutation) VisitorsIDs() (ids []int) {
	for id := range m.visitors {
		ids = append(ids, id)
	}
	return
}

// ResetVisitors resets all changes to the "visitors" edge.
func (m *GymMutation) ResetVisitors() {
	m.visitors = nil
	m.clearedvisitors = false
	m.removedvisitors = nil
}

// AddManagerIDs adds the "managers" edge to the User entity by ids.
func (m *GymMutation) AddManagerIDs(ids ...int) {
	if m.managers == nil {
		m.managers = make(map[int]struct{})
	}
	for i := range ids {
		m.managers[ids[i]] = struct{}{}
	}
}

// ClearManagers clears the "managers" edge to the User entity.
func (m *GymMutation) ClearManagers() {
	m.clearedmanagers = true
}

// ManagersCleared reports if the "managers" edge to the User entity was cleared.
func (m *GymMutation) ManagersCleared() bool {
	return m.clearedmanagers
}

// RemoveManagerIDs removes the "managers" edge to the User entity by IDs.
func (m *GymMutation) RemoveManagerIDs(ids ...int) {
	if m.removedmanagers == nil {
		m.removedmanagers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.managers, ids[i])
		m.removedmanagers[ids[i]] = struct{}{}
	}
}

// RemovedManagers returns the removed IDs of the "managers" edge to the User entity.
func (m *GymMutation) RemovedManagersIDs() (ids []int) {
	for id := range m.removedmanagers {
		ids = append(ids, id)
	}
	return
}

// ManagersIDs returns the "managers" edge IDs in the mutation.
func (m *GymMutation) ManagersIDs() (ids []int) {
	for id := range m.managers {
		ids = append(ids, id)
	}
	return
}

// ResetManagers resets all changes to the "managers" edge.
func (m *GymMutation) ResetManagers() {
	m.managers = nil
	m.clearedmanagers = false
	m.removedmanagers = nil
}

// AddAbonementTypeIDs adds the "abonement_type" edge to the AbonementType entity by ids.
func (m *GymMutation) AddAbonementTypeIDs(ids ...int) {
	if m.abonement_type == nil {
		m.abonement_type = make(map[int]struct{})
	}
	for i := range ids {
		m.abonement_type[ids[i]] = struct{}{}
	}
}

// ClearAbonementType clears the "abonement_type" edge to the AbonementType entity.
func (m *GymMutation) ClearAbonementType() {
	m.clearedabonement_type = true
}

// AbonementTypeCleared reports if the "abonement_type" edge to the AbonementType entity was cleared.
func (m *GymMutation) AbonementTypeCleared() bool {
	return m.clearedabonement_type
}

// RemoveAbonementTypeIDs removes the "abonement_type" edge to the AbonementType entity by IDs.
func (m *GymMutation) RemoveAbonementTypeIDs(ids ...int) {
	if m.removedabonement_type == nil {
		m.removedabonement_type = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.abonement_type, ids[i])
		m.removedabonement_type[ids[i]] = struct{}{}
	}
}

// RemovedAbonementType returns the removed IDs of the "abonement_type" edge to the AbonementType entity.
func (m *GymMutation) RemovedAbonementTypeIDs() (ids []int) {
	for id := range m.removedabonement_type {
		ids = append(ids, id)
	}
	return
}

// AbonementTypeIDs returns the "abonement_type" edge IDs in the mutation.
func (m *GymMutation) AbonementTypeIDs() (ids []int) {
	for id := range m.abonement_type {
		ids = append(ids, id)
	}
	return
}

// ResetAbonementType resets all changes to the "abonement_type" edge.
func (m *GymMutation) ResetAbonementType() {
	m.abonement_type = nil
	m.clearedabonement_type = false
	m.removedabonement_type = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *GymMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *GymMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *GymMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *GymMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *GymMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *GymMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddAbonementIDs adds the "abonements" edge to the Abonement entity by ids.
func (m *GymMutation) AddAbonementIDs(ids ...int) {
	if m.abonements == nil {
		m.abonements = make(map[int]struct{})
	}
	for i := range ids {
		m.abonements[ids[i]] = struct{}{}
	}
}

// ClearAbonements clears the "abonements" edge to the Abonement entity.
func (m *GymMutation) ClearAbonements() {
	m.clearedabonements = true
}

// AbonementsCleared reports if the "abonements" edge to the Abonement entity was cleared.
func (m *GymMutation) AbonementsCleared() bool {
	return m.clearedabonements
}

// RemoveAbonementIDs removes the "abonements" edge to the Abonement entity by IDs.
func (m *GymMutation) RemoveAbonementIDs(ids ...int) {
	if m.removedabonements == nil {
		m.removedabonements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.abonements, ids[i])
		m.removedabonements[ids[i]] = struct{}{}
	}
}

// RemovedAbonements returns the removed IDs of the "abonements" edge to the Abonement entity.
func (m *GymMutation) RemovedAbonementsIDs() (ids []int) {
	for id := range m.removedabonements {
		ids = append(ids, id)
	}
	return
}

// AbonementsIDs returns the "abonements" edge IDs in the mutation.
func (m *GymMutation) AbonementsIDs() (ids []int) {
	for id := range m.abonements {
		ids = append(ids, id)
	}
	return
}

// ResetAbonements resets all changes to the "abonements" edge.
func (m *GymMutation) ResetAbonements() {
	m.abonements = nil
	m.clearedabonements = false
	m.removedabonements = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *GymMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *GymMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *GymMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *GymMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *GymMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *GymMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *GymMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddManagerRoleIDs adds the "manager_roles" edge to the ManagerRole entity by ids.
func (m *GymMutation) AddManagerRoleIDs(ids ...int) {
	if m.manager_roles == nil {
		m.manager_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.manager_roles[ids[i]] = struct{}{}
	}
}

// ClearManagerRoles clears the "manager_roles" edge to the ManagerRole entity.
func (m *GymMutation) ClearManagerRoles() {
	m.clearedmanager_roles = true
}

// ManagerRolesCleared reports if the "manager_roles" edge to the ManagerRole entity was cleared.
func (m *GymMutation) ManagerRolesCleared() bool {
	return m.clearedmanager_roles
}

// RemoveManagerRoleIDs removes the "manager_roles" edge to the ManagerRole entity by IDs.
func (m *GymMutation) RemoveManagerRoleIDs(ids ...int) {
	if m.removedmanager_roles == nil {
		m.removedmanager_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.manager_roles, ids[i])
		m.removedmanager_roles[ids[i]] = struct{}{}
	}
}

// RemovedManagerRoles returns the removed IDs of the "manager_roles" edge to the ManagerRole entity.
func (m *GymMutation) RemovedManagerRolesIDs() (ids []int) {
	for id := range m.removedmanager_roles {
		ids = append(ids, id)
	}
	return
}

// ManagerRolesIDs returns the "manager_roles" edge IDs in the mutation.
func (m *GymMutation) ManagerRolesIDs() (ids []int) {
	for id := range m.manager_roles {
		ids = append(ids, id)
	}
	return
}

// ResetManagerRoles resets all changes to the "manager_roles" edge.
func (m *GymMutation) ResetManagerRoles() {
	m.manager_roles = nil
	m.clearedmanager_roles = false
	m.removedmanager_roles = nil
}

// SetPaymentRequisiteID sets the "payment_requisite" edge to the PaymentRequisite entity by id.
func (m *GymMutation) SetPaymentRequisiteID(id int) {
	m.payment_requisite = &id
}

// ClearPaymentRequisite clears the "payment_requisite" edge to the PaymentRequisite entity.
func (m *GymMutation) ClearPaymentRequisite() {
	m.clearedpayment_requisite = true
}

// PaymentRequisiteCleared reports if the "payment_requisite" edge to the PaymentRequisite entity was cleared.
func (m *GymMutation) PaymentRequisiteCleared() bool {
	return m.clearedpayment_requisite
}

// PaymentRequisiteID returns the "payment_requisite" edge ID in the mutation.
func (m *GymMutation) PaymentRequisiteID() (id int, exists bool) {
	if m.payment_requisite != nil {
		return *m.payment_requisite, true
	}
	return
}

// PaymentRequisiteIDs returns the "payment_requisite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentRequisiteID instead. It exists only for internal usage by the builders.
func (m *GymMutation) PaymentRequisiteIDs() (ids []int) {
	if id := m.payment_requisite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentRequisite resets all changes to the "payment_requisite" edge.
func (m *GymMutation) ResetPaymentRequisite() {
	m.payment_requisite = nil
	m.clearedpayment_requisite = false
}

// Where appends a list predicates to the GymMutation builder.
func (m *GymMutation) Where(ps ...predicate.Gym) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GymMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GymMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Gym, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GymMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GymMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Gym).
func (m *GymMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GymMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, gym.FieldName)
	}
	if m.currency_id != nil {
		fields = append(fields, gym.FieldCurrencyID)
	}
	if m.phone != nil {
		fields = append(fields, gym.FieldPhone)
	}
	if m.mail != nil {
		fields = append(fields, gym.FieldMail)
	}
	if m.address != nil {
		fields = append(fields, gym.FieldAddress)
	}
	if m.web_site != nil {
		fields = append(fields, gym.FieldWebSite)
	}
	if m.description != nil {
		fields = append(fields, gym.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, gym.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gym.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GymMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gym.FieldName:
		return m.Name()
	case gym.FieldCurrencyID:
		return m.CurrencyID()
	case gym.FieldPhone:
		return m.Phone()
	case gym.FieldMail:
		return m.Mail()
	case gym.FieldAddress:
		return m.Address()
	case gym.FieldWebSite:
		return m.WebSite()
	case gym.FieldDescription:
		return m.Description()
	case gym.FieldCreatedAt:
		return m.CreatedAt()
	case gym.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GymMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gym.FieldName:
		return m.OldName(ctx)
	case gym.FieldCurrencyID:
		return m.OldCurrencyID(ctx)
	case gym.FieldPhone:
		return m.OldPhone(ctx)
	case gym.FieldMail:
		return m.OldMail(ctx)
	case gym.FieldAddress:
		return m.OldAddress(ctx)
	case gym.FieldWebSite:
		return m.OldWebSite(ctx)
	case gym.FieldDescription:
		return m.OldDescription(ctx)
	case gym.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gym.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Gym field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GymMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gym.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case gym.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyID(v)
		return nil
	case gym.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case gym.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case gym.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case gym.FieldWebSite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebSite(v)
		return nil
	case gym.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case gym.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gym.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Gym field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GymMutation) AddedFields() []string {
	var fields []string
	if m.addcurrency_id != nil {
		fields = append(fields, gym.FieldCurrencyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GymMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gym.FieldCurrencyID:
		return m.AddedCurrencyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GymMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gym.FieldCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrencyID(v)
		return nil
	}
	return fmt.Errorf("unknown Gym numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GymMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gym.FieldAddress) {
		fields = append(fields, gym.FieldAddress)
	}
	if m.FieldCleared(gym.FieldWebSite) {
		fields = append(fields, gym.FieldWebSite)
	}
	if m.FieldCleared(gym.FieldDescription) {
		fields = append(fields, gym.FieldDescription)
	}
	if m.FieldCleared(gym.FieldUpdatedAt) {
		fields = append(fields, gym.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GymMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GymMutation) ClearField(name string) error {
	switch name {
	case gym.FieldAddress:
		m.ClearAddress()
		return nil
	case gym.FieldWebSite:
		m.ClearWebSite()
		return nil
	case gym.FieldDescription:
		m.ClearDescription()
		return nil
	case gym.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Gym nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GymMutation) ResetField(name string) error {
	switch name {
	case gym.FieldName:
		m.ResetName()
		return nil
	case gym.FieldCurrencyID:
		m.ResetCurrencyID()
		return nil
	case gym.FieldPhone:
		m.ResetPhone()
		return nil
	case gym.FieldMail:
		m.ResetMail()
		return nil
	case gym.FieldAddress:
		m.ResetAddress()
		return nil
	case gym.FieldWebSite:
		m.ResetWebSite()
		return nil
	case gym.FieldDescription:
		m.ResetDescription()
		return nil
	case gym.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gym.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Gym field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GymMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.visitors != nil {
		edges = append(edges, gym.EdgeVisitors)
	}
	if m.managers != nil {
		edges = append(edges, gym.EdgeManagers)
	}
	if m.abonement_type != nil {
		edges = append(edges, gym.EdgeAbonementType)
	}
	if m.owner != nil {
		edges = append(edges, gym.EdgeOwner)
	}
	if m.abonements != nil {
		edges = append(edges, gym.EdgeAbonements)
	}
	if m.user_roles != nil {
		edges = append(edges, gym.EdgeUserRoles)
	}
	if m.manager_roles != nil {
		edges = append(edges, gym.EdgeManagerRoles)
	}
	if m.payment_requisite != nil {
		edges = append(edges, gym.EdgePaymentRequisite)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GymMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gym.EdgeVisitors:
		ids := make([]ent.Value, 0, len(m.visitors))
		for id := range m.visitors {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeManagers:
		ids := make([]ent.Value, 0, len(m.managers))
		for id := range m.managers {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeAbonementType:
		ids := make([]ent.Value, 0, len(m.abonement_type))
		for id := range m.abonement_type {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case gym.EdgeAbonements:
		ids := make([]ent.Value, 0, len(m.abonements))
		for id := range m.abonements {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeManagerRoles:
		ids := make([]ent.Value, 0, len(m.manager_roles))
		for id := range m.manager_roles {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgePaymentRequisite:
		if id := m.payment_requisite; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GymMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedvisitors != nil {
		edges = append(edges, gym.EdgeVisitors)
	}
	if m.removedmanagers != nil {
		edges = append(edges, gym.EdgeManagers)
	}
	if m.removedabonement_type != nil {
		edges = append(edges, gym.EdgeAbonementType)
	}
	if m.removedabonements != nil {
		edges = append(edges, gym.EdgeAbonements)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, gym.EdgeUserRoles)
	}
	if m.removedmanager_roles != nil {
		edges = append(edges, gym.EdgeManagerRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GymMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gym.EdgeVisitors:
		ids := make([]ent.Value, 0, len(m.removedvisitors))
		for id := range m.removedvisitors {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeManagers:
		ids := make([]ent.Value, 0, len(m.removedmanagers))
		for id := range m.removedmanagers {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeAbonementType:
		ids := make([]ent.Value, 0, len(m.removedabonement_type))
		for id := range m.removedabonement_type {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeAbonements:
		ids := make([]ent.Value, 0, len(m.removedabonements))
		for id := range m.removedabonements {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case gym.EdgeManagerRoles:
		ids := make([]ent.Value, 0, len(m.removedmanager_roles))
		for id := range m.removedmanager_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GymMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedvisitors {
		edges = append(edges, gym.EdgeVisitors)
	}
	if m.clearedmanagers {
		edges = append(edges, gym.EdgeManagers)
	}
	if m.clearedabonement_type {
		edges = append(edges, gym.EdgeAbonementType)
	}
	if m.clearedowner {
		edges = append(edges, gym.EdgeOwner)
	}
	if m.clearedabonements {
		edges = append(edges, gym.EdgeAbonements)
	}
	if m.cleareduser_roles {
		edges = append(edges, gym.EdgeUserRoles)
	}
	if m.clearedmanager_roles {
		edges = append(edges, gym.EdgeManagerRoles)
	}
	if m.clearedpayment_requisite {
		edges = append(edges, gym.EdgePaymentRequisite)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GymMutation) EdgeCleared(name string) bool {
	switch name {
	case gym.EdgeVisitors:
		return m.clearedvisitors
	case gym.EdgeManagers:
		return m.clearedmanagers
	case gym.EdgeAbonementType:
		return m.clearedabonement_type
	case gym.EdgeOwner:
		return m.clearedowner
	case gym.EdgeAbonements:
		return m.clearedabonements
	case gym.EdgeUserRoles:
		return m.cleareduser_roles
	case gym.EdgeManagerRoles:
		return m.clearedmanager_roles
	case gym.EdgePaymentRequisite:
		return m.clearedpayment_requisite
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GymMutation) ClearEdge(name string) error {
	switch name {
	case gym.EdgeOwner:
		m.ClearOwner()
		return nil
	case gym.EdgePaymentRequisite:
		m.ClearPaymentRequisite()
		return nil
	}
	return fmt.Errorf("unknown Gym unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GymMutation) ResetEdge(name string) error {
	switch name {
	case gym.EdgeVisitors:
		m.ResetVisitors()
		return nil
	case gym.EdgeManagers:
		m.ResetManagers()
		return nil
	case gym.EdgeAbonementType:
		m.ResetAbonementType()
		return nil
	case gym.EdgeOwner:
		m.ResetOwner()
		return nil
	case gym.EdgeAbonements:
		m.ResetAbonements()
		return nil
	case gym.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case gym.EdgeManagerRoles:
		m.ResetManagerRoles()
		return nil
	case gym.EdgePaymentRequisite:
		m.ResetPaymentRequisite()
		return nil
	}
	return fmt.Errorf("unknown Gym edge %s", name)
}

// ManagerRoleMutation represents an operation that mutates the ManagerRole nodes in the graph.
type ManagerRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	manager_role  *managerrole.ManagerRole
	created_at    *time.Time
	updated_at    *time.Time
	is_close      *bool
	clearedFields map[string]struct{}
	gym           *int
	clearedgym    bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ManagerRole, error)
	predicates    []predicate.ManagerRole
}

var _ ent.Mutation = (*ManagerRoleMutation)(nil)

// managerroleOption allows management of the mutation configuration using functional options.
type managerroleOption func(*ManagerRoleMutation)

// newManagerRoleMutation creates new mutation for the ManagerRole entity.
func newManagerRoleMutation(c config, op Op, opts ...managerroleOption) *ManagerRoleMutation {
	m := &ManagerRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeManagerRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withManagerRoleID sets the ID field of the mutation.
func withManagerRoleID(id int) managerroleOption {
	return func(m *ManagerRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *ManagerRole
		)
		m.oldValue = func(ctx context.Context) (*ManagerRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ManagerRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withManagerRole sets the old ManagerRole of the mutation.
func withManagerRole(node *ManagerRole) managerroleOption {
	return func(m *ManagerRoleMutation) {
		m.oldValue = func(context.Context) (*ManagerRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ManagerRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ManagerRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ManagerRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ManagerRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ManagerRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetManagerRole sets the "manager_role" field.
func (m *ManagerRoleMutation) SetManagerRole(mr managerrole.ManagerRole) {
	m.manager_role = &mr
}

// ManagerRole returns the value of the "manager_role" field in the mutation.
func (m *ManagerRoleMutation) ManagerRole() (r managerrole.ManagerRole, exists bool) {
	v := m.manager_role
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerRole returns the old "manager_role" field's value of the ManagerRole entity.
// If the ManagerRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerRoleMutation) OldManagerRole(ctx context.Context) (v managerrole.ManagerRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerRole: %w", err)
	}
	return oldValue.ManagerRole, nil
}

// ResetManagerRole resets all changes to the "manager_role" field.
func (m *ManagerRoleMutation) ResetManagerRole() {
	m.manager_role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ManagerRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ManagerRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ManagerRole entity.
// If the ManagerRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ManagerRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ManagerRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ManagerRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ManagerRole entity.
// If the ManagerRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ManagerRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[managerrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ManagerRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[managerrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ManagerRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, managerrole.FieldUpdatedAt)
}

// SetIsClose sets the "is_close" field.
func (m *ManagerRoleMutation) SetIsClose(b bool) {
	m.is_close = &b
}

// IsClose returns the value of the "is_close" field in the mutation.
func (m *ManagerRoleMutation) IsClose() (r bool, exists bool) {
	v := m.is_close
	if v == nil {
		return
	}
	return *v, true
}

// OldIsClose returns the old "is_close" field's value of the ManagerRole entity.
// If the ManagerRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerRoleMutation) OldIsClose(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsClose: %w", err)
	}
	return oldValue.IsClose, nil
}

// ResetIsClose resets all changes to the "is_close" field.
func (m *ManagerRoleMutation) ResetIsClose() {
	m.is_close = nil
}

// SetGymID sets the "gym" edge to the Gym entity by id.
func (m *ManagerRoleMutation) SetGymID(id int) {
	m.gym = &id
}

// ClearGym clears the "gym" edge to the Gym entity.
func (m *ManagerRoleMutation) ClearGym() {
	m.clearedgym = true
}

// GymCleared reports if the "gym" edge to the Gym entity was cleared.
func (m *ManagerRoleMutation) GymCleared() bool {
	return m.clearedgym
}

// GymID returns the "gym" edge ID in the mutation.
func (m *ManagerRoleMutation) GymID() (id int, exists bool) {
	if m.gym != nil {
		return *m.gym, true
	}
	return
}

// GymIDs returns the "gym" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GymID instead. It exists only for internal usage by the builders.
func (m *ManagerRoleMutation) GymIDs() (ids []int) {
	if id := m.gym; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGym resets all changes to the "gym" edge.
func (m *ManagerRoleMutation) ResetGym() {
	m.gym = nil
	m.clearedgym = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ManagerRoleMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ManagerRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ManagerRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ManagerRoleMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ManagerRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ManagerRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ManagerRoleMutation builder.
func (m *ManagerRoleMutation) Where(ps ...predicate.ManagerRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ManagerRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ManagerRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ManagerRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ManagerRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ManagerRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ManagerRole).
func (m *ManagerRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ManagerRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.manager_role != nil {
		fields = append(fields, managerrole.FieldManagerRole)
	}
	if m.created_at != nil {
		fields = append(fields, managerrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, managerrole.FieldUpdatedAt)
	}
	if m.is_close != nil {
		fields = append(fields, managerrole.FieldIsClose)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ManagerRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case managerrole.FieldManagerRole:
		return m.ManagerRole()
	case managerrole.FieldCreatedAt:
		return m.CreatedAt()
	case managerrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case managerrole.FieldIsClose:
		return m.IsClose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ManagerRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case managerrole.FieldManagerRole:
		return m.OldManagerRole(ctx)
	case managerrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case managerrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case managerrole.FieldIsClose:
		return m.OldIsClose(ctx)
	}
	return nil, fmt.Errorf("unknown ManagerRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case managerrole.FieldManagerRole:
		v, ok := value.(managerrole.ManagerRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerRole(v)
		return nil
	case managerrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case managerrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case managerrole.FieldIsClose:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsClose(v)
		return nil
	}
	return fmt.Errorf("unknown ManagerRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ManagerRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ManagerRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ManagerRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ManagerRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(managerrole.FieldUpdatedAt) {
		fields = append(fields, managerrole.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ManagerRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ManagerRoleMutation) ClearField(name string) error {
	switch name {
	case managerrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ManagerRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ManagerRoleMutation) ResetField(name string) error {
	switch name {
	case managerrole.FieldManagerRole:
		m.ResetManagerRole()
		return nil
	case managerrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case managerrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case managerrole.FieldIsClose:
		m.ResetIsClose()
		return nil
	}
	return fmt.Errorf("unknown ManagerRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ManagerRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.gym != nil {
		edges = append(edges, managerrole.EdgeGym)
	}
	if m.user != nil {
		edges = append(edges, managerrole.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ManagerRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case managerrole.EdgeGym:
		if id := m.gym; id != nil {
			return []ent.Value{*id}
		}
	case managerrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ManagerRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ManagerRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ManagerRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgym {
		edges = append(edges, managerrole.EdgeGym)
	}
	if m.cleareduser {
		edges = append(edges, managerrole.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ManagerRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case managerrole.EdgeGym:
		return m.clearedgym
	case managerrole.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ManagerRoleMutation) ClearEdge(name string) error {
	switch name {
	case managerrole.EdgeGym:
		m.ClearGym()
		return nil
	case managerrole.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ManagerRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ManagerRoleMutation) ResetEdge(name string) error {
	switch name {
	case managerrole.EdgeGym:
		m.ResetGym()
		return nil
	case managerrole.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ManagerRole edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	amount           *float64
	addamount        *float64
	link_photo       *string
	created_at       *time.Time
	confirmed_at     *time.Time
	is_confirmed     *bool
	clearedFields    map[string]struct{}
	abonement        *int
	clearedabonement bool
	done             bool
	oldValue         func(context.Context) (*Payment, error)
	predicates       []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetLinkPhoto sets the "link_photo" field.
func (m *PaymentMutation) SetLinkPhoto(s string) {
	m.link_photo = &s
}

// LinkPhoto returns the value of the "link_photo" field in the mutation.
func (m *PaymentMutation) LinkPhoto() (r string, exists bool) {
	v := m.link_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkPhoto returns the old "link_photo" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldLinkPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkPhoto: %w", err)
	}
	return oldValue.LinkPhoto, nil
}

// ClearLinkPhoto clears the value of the "link_photo" field.
func (m *PaymentMutation) ClearLinkPhoto() {
	m.link_photo = nil
	m.clearedFields[payment.FieldLinkPhoto] = struct{}{}
}

// LinkPhotoCleared returns if the "link_photo" field was cleared in this mutation.
func (m *PaymentMutation) LinkPhotoCleared() bool {
	_, ok := m.clearedFields[payment.FieldLinkPhoto]
	return ok
}

// ResetLinkPhoto resets all changes to the "link_photo" field.
func (m *PaymentMutation) ResetLinkPhoto() {
	m.link_photo = nil
	delete(m.clearedFields, payment.FieldLinkPhoto)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConfirmedAt sets the "confirmed_at" field.
func (m *PaymentMutation) SetConfirmedAt(t time.Time) {
	m.confirmed_at = &t
}

// ConfirmedAt returns the value of the "confirmed_at" field in the mutation.
func (m *PaymentMutation) ConfirmedAt() (r time.Time, exists bool) {
	v := m.confirmed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedAt returns the old "confirmed_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldConfirmedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedAt: %w", err)
	}
	return oldValue.ConfirmedAt, nil
}

// ClearConfirmedAt clears the value of the "confirmed_at" field.
func (m *PaymentMutation) ClearConfirmedAt() {
	m.confirmed_at = nil
	m.clearedFields[payment.FieldConfirmedAt] = struct{}{}
}

// ConfirmedAtCleared returns if the "confirmed_at" field was cleared in this mutation.
func (m *PaymentMutation) ConfirmedAtCleared() bool {
	_, ok := m.clearedFields[payment.FieldConfirmedAt]
	return ok
}

// ResetConfirmedAt resets all changes to the "confirmed_at" field.
func (m *PaymentMutation) ResetConfirmedAt() {
	m.confirmed_at = nil
	delete(m.clearedFields, payment.FieldConfirmedAt)
}

// SetIsConfirmed sets the "is_confirmed" field.
func (m *PaymentMutation) SetIsConfirmed(b bool) {
	m.is_confirmed = &b
}

// IsConfirmed returns the value of the "is_confirmed" field in the mutation.
func (m *PaymentMutation) IsConfirmed() (r bool, exists bool) {
	v := m.is_confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsConfirmed returns the old "is_confirmed" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldIsConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsConfirmed: %w", err)
	}
	return oldValue.IsConfirmed, nil
}

// ResetIsConfirmed resets all changes to the "is_confirmed" field.
func (m *PaymentMutation) ResetIsConfirmed() {
	m.is_confirmed = nil
}

// SetAbonementID sets the "abonement" edge to the Abonement entity by id.
func (m *PaymentMutation) SetAbonementID(id int) {
	m.abonement = &id
}

// ClearAbonement clears the "abonement" edge to the Abonement entity.
func (m *PaymentMutation) ClearAbonement() {
	m.clearedabonement = true
}

// AbonementCleared reports if the "abonement" edge to the Abonement entity was cleared.
func (m *PaymentMutation) AbonementCleared() bool {
	return m.clearedabonement
}

// AbonementID returns the "abonement" edge ID in the mutation.
func (m *PaymentMutation) AbonementID() (id int, exists bool) {
	if m.abonement != nil {
		return *m.abonement, true
	}
	return
}

// AbonementIDs returns the "abonement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbonementID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) AbonementIDs() (ids []int) {
	if id := m.abonement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbonement resets all changes to the "abonement" edge.
func (m *PaymentMutation) ResetAbonement() {
	m.abonement = nil
	m.clearedabonement = false
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.link_photo != nil {
		fields = append(fields, payment.FieldLinkPhoto)
	}
	if m.created_at != nil {
		fields = append(fields, payment.FieldCreatedAt)
	}
	if m.confirmed_at != nil {
		fields = append(fields, payment.FieldConfirmedAt)
	}
	if m.is_confirmed != nil {
		fields = append(fields, payment.FieldIsConfirmed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldLinkPhoto:
		return m.LinkPhoto()
	case payment.FieldCreatedAt:
		return m.CreatedAt()
	case payment.FieldConfirmedAt:
		return m.ConfirmedAt()
	case payment.FieldIsConfirmed:
		return m.IsConfirmed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldLinkPhoto:
		return m.OldLinkPhoto(ctx)
	case payment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payment.FieldConfirmedAt:
		return m.OldConfirmedAt(ctx)
	case payment.FieldIsConfirmed:
		return m.OldIsConfirmed(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldLinkPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkPhoto(v)
		return nil
	case payment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payment.FieldConfirmedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedAt(v)
		return nil
	case payment.FieldIsConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsConfirmed(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldLinkPhoto) {
		fields = append(fields, payment.FieldLinkPhoto)
	}
	if m.FieldCleared(payment.FieldConfirmedAt) {
		fields = append(fields, payment.FieldConfirmedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldLinkPhoto:
		m.ClearLinkPhoto()
		return nil
	case payment.FieldConfirmedAt:
		m.ClearConfirmedAt()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldLinkPhoto:
		m.ResetLinkPhoto()
		return nil
	case payment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payment.FieldConfirmedAt:
		m.ResetConfirmedAt()
		return nil
	case payment.FieldIsConfirmed:
		m.ResetIsConfirmed()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.abonement != nil {
		edges = append(edges, payment.EdgeAbonement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeAbonement:
		if id := m.abonement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedabonement {
		edges = append(edges, payment.EdgeAbonement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeAbonement:
		return m.clearedabonement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeAbonement:
		m.ClearAbonement()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeAbonement:
		m.ResetAbonement()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymentRequisiteMutation represents an operation that mutates the PaymentRequisite nodes in the graph.
type PaymentRequisiteMutation struct {
	config
	op               Op
	typ              string
	id               *int
	bank_kard_1      *string
	bank_kard_2      *string
	bank_kard_3      *string
	bank_kard_4      *string
	bank_kard_5      *string
	name_bank_kard_1 *string
	name_bank_kard_2 *string
	name_bank_kard_3 *string
	name_bank_kard_4 *string
	name_bank_kard_5 *string
	name_bank        *string
	iban             *string
	edrpou           *string
	receiver_name    *string
	payment_purpose  *string
	mfo              *string
	account_number   *string
	clearedFields    map[string]struct{}
	gym              *int
	clearedgym       bool
	done             bool
	oldValue         func(context.Context) (*PaymentRequisite, error)
	predicates       []predicate.PaymentRequisite
}

var _ ent.Mutation = (*PaymentRequisiteMutation)(nil)

// paymentrequisiteOption allows management of the mutation configuration using functional options.
type paymentrequisiteOption func(*PaymentRequisiteMutation)

// newPaymentRequisiteMutation creates new mutation for the PaymentRequisite entity.
func newPaymentRequisiteMutation(c config, op Op, opts ...paymentrequisiteOption) *PaymentRequisiteMutation {
	m := &PaymentRequisiteMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentRequisite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentRequisiteID sets the ID field of the mutation.
func withPaymentRequisiteID(id int) paymentrequisiteOption {
	return func(m *PaymentRequisiteMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentRequisite
		)
		m.oldValue = func(ctx context.Context) (*PaymentRequisite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentRequisite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentRequisite sets the old PaymentRequisite of the mutation.
func withPaymentRequisite(node *PaymentRequisite) paymentrequisiteOption {
	return func(m *PaymentRequisiteMutation) {
		m.oldValue = func(context.Context) (*PaymentRequisite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentRequisiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentRequisiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentRequisiteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentRequisiteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentRequisite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBankKard1 sets the "bank_kard_1" field.
func (m *PaymentRequisiteMutation) SetBankKard1(s string) {
	m.bank_kard_1 = &s
}

// BankKard1 returns the value of the "bank_kard_1" field in the mutation.
func (m *PaymentRequisiteMutation) BankKard1() (r string, exists bool) {
	v := m.bank_kard_1
	if v == nil {
		return
	}
	return *v, true
}

// OldBankKard1 returns the old "bank_kard_1" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldBankKard1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankKard1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankKard1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankKard1: %w", err)
	}
	return oldValue.BankKard1, nil
}

// ClearBankKard1 clears the value of the "bank_kard_1" field.
func (m *PaymentRequisiteMutation) ClearBankKard1() {
	m.bank_kard_1 = nil
	m.clearedFields[paymentrequisite.FieldBankKard1] = struct{}{}
}

// BankKard1Cleared returns if the "bank_kard_1" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) BankKard1Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldBankKard1]
	return ok
}

// ResetBankKard1 resets all changes to the "bank_kard_1" field.
func (m *PaymentRequisiteMutation) ResetBankKard1() {
	m.bank_kard_1 = nil
	delete(m.clearedFields, paymentrequisite.FieldBankKard1)
}

// SetBankKard2 sets the "bank_kard_2" field.
func (m *PaymentRequisiteMutation) SetBankKard2(s string) {
	m.bank_kard_2 = &s
}

// BankKard2 returns the value of the "bank_kard_2" field in the mutation.
func (m *PaymentRequisiteMutation) BankKard2() (r string, exists bool) {
	v := m.bank_kard_2
	if v == nil {
		return
	}
	return *v, true
}

// OldBankKard2 returns the old "bank_kard_2" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldBankKard2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankKard2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankKard2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankKard2: %w", err)
	}
	return oldValue.BankKard2, nil
}

// ClearBankKard2 clears the value of the "bank_kard_2" field.
func (m *PaymentRequisiteMutation) ClearBankKard2() {
	m.bank_kard_2 = nil
	m.clearedFields[paymentrequisite.FieldBankKard2] = struct{}{}
}

// BankKard2Cleared returns if the "bank_kard_2" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) BankKard2Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldBankKard2]
	return ok
}

// ResetBankKard2 resets all changes to the "bank_kard_2" field.
func (m *PaymentRequisiteMutation) ResetBankKard2() {
	m.bank_kard_2 = nil
	delete(m.clearedFields, paymentrequisite.FieldBankKard2)
}

// SetBankKard3 sets the "bank_kard_3" field.
func (m *PaymentRequisiteMutation) SetBankKard3(s string) {
	m.bank_kard_3 = &s
}

// BankKard3 returns the value of the "bank_kard_3" field in the mutation.
func (m *PaymentRequisiteMutation) BankKard3() (r string, exists bool) {
	v := m.bank_kard_3
	if v == nil {
		return
	}
	return *v, true
}

// OldBankKard3 returns the old "bank_kard_3" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldBankKard3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankKard3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankKard3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankKard3: %w", err)
	}
	return oldValue.BankKard3, nil
}

// ClearBankKard3 clears the value of the "bank_kard_3" field.
func (m *PaymentRequisiteMutation) ClearBankKard3() {
	m.bank_kard_3 = nil
	m.clearedFields[paymentrequisite.FieldBankKard3] = struct{}{}
}

// BankKard3Cleared returns if the "bank_kard_3" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) BankKard3Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldBankKard3]
	return ok
}

// ResetBankKard3 resets all changes to the "bank_kard_3" field.
func (m *PaymentRequisiteMutation) ResetBankKard3() {
	m.bank_kard_3 = nil
	delete(m.clearedFields, paymentrequisite.FieldBankKard3)
}

// SetBankKard4 sets the "bank_kard_4" field.
func (m *PaymentRequisiteMutation) SetBankKard4(s string) {
	m.bank_kard_4 = &s
}

// BankKard4 returns the value of the "bank_kard_4" field in the mutation.
func (m *PaymentRequisiteMutation) BankKard4() (r string, exists bool) {
	v := m.bank_kard_4
	if v == nil {
		return
	}
	return *v, true
}

// OldBankKard4 returns the old "bank_kard_4" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldBankKard4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankKard4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankKard4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankKard4: %w", err)
	}
	return oldValue.BankKard4, nil
}

// ClearBankKard4 clears the value of the "bank_kard_4" field.
func (m *PaymentRequisiteMutation) ClearBankKard4() {
	m.bank_kard_4 = nil
	m.clearedFields[paymentrequisite.FieldBankKard4] = struct{}{}
}

// BankKard4Cleared returns if the "bank_kard_4" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) BankKard4Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldBankKard4]
	return ok
}

// ResetBankKard4 resets all changes to the "bank_kard_4" field.
func (m *PaymentRequisiteMutation) ResetBankKard4() {
	m.bank_kard_4 = nil
	delete(m.clearedFields, paymentrequisite.FieldBankKard4)
}

// SetBankKard5 sets the "bank_kard_5" field.
func (m *PaymentRequisiteMutation) SetBankKard5(s string) {
	m.bank_kard_5 = &s
}

// BankKard5 returns the value of the "bank_kard_5" field in the mutation.
func (m *PaymentRequisiteMutation) BankKard5() (r string, exists bool) {
	v := m.bank_kard_5
	if v == nil {
		return
	}
	return *v, true
}

// OldBankKard5 returns the old "bank_kard_5" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldBankKard5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankKard5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankKard5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankKard5: %w", err)
	}
	return oldValue.BankKard5, nil
}

// ClearBankKard5 clears the value of the "bank_kard_5" field.
func (m *PaymentRequisiteMutation) ClearBankKard5() {
	m.bank_kard_5 = nil
	m.clearedFields[paymentrequisite.FieldBankKard5] = struct{}{}
}

// BankKard5Cleared returns if the "bank_kard_5" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) BankKard5Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldBankKard5]
	return ok
}

// ResetBankKard5 resets all changes to the "bank_kard_5" field.
func (m *PaymentRequisiteMutation) ResetBankKard5() {
	m.bank_kard_5 = nil
	delete(m.clearedFields, paymentrequisite.FieldBankKard5)
}

// SetNameBankKard1 sets the "name_bank_kard_1" field.
func (m *PaymentRequisiteMutation) SetNameBankKard1(s string) {
	m.name_bank_kard_1 = &s
}

// NameBankKard1 returns the value of the "name_bank_kard_1" field in the mutation.
func (m *PaymentRequisiteMutation) NameBankKard1() (r string, exists bool) {
	v := m.name_bank_kard_1
	if v == nil {
		return
	}
	return *v, true
}

// OldNameBankKard1 returns the old "name_bank_kard_1" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldNameBankKard1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameBankKard1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameBankKard1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameBankKard1: %w", err)
	}
	return oldValue.NameBankKard1, nil
}

// ClearNameBankKard1 clears the value of the "name_bank_kard_1" field.
func (m *PaymentRequisiteMutation) ClearNameBankKard1() {
	m.name_bank_kard_1 = nil
	m.clearedFields[paymentrequisite.FieldNameBankKard1] = struct{}{}
}

// NameBankKard1Cleared returns if the "name_bank_kard_1" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) NameBankKard1Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldNameBankKard1]
	return ok
}

// ResetNameBankKard1 resets all changes to the "name_bank_kard_1" field.
func (m *PaymentRequisiteMutation) ResetNameBankKard1() {
	m.name_bank_kard_1 = nil
	delete(m.clearedFields, paymentrequisite.FieldNameBankKard1)
}

// SetNameBankKard2 sets the "name_bank_kard_2" field.
func (m *PaymentRequisiteMutation) SetNameBankKard2(s string) {
	m.name_bank_kard_2 = &s
}

// NameBankKard2 returns the value of the "name_bank_kard_2" field in the mutation.
func (m *PaymentRequisiteMutation) NameBankKard2() (r string, exists bool) {
	v := m.name_bank_kard_2
	if v == nil {
		return
	}
	return *v, true
}

// OldNameBankKard2 returns the old "name_bank_kard_2" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldNameBankKard2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameBankKard2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameBankKard2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameBankKard2: %w", err)
	}
	return oldValue.NameBankKard2, nil
}

// ClearNameBankKard2 clears the value of the "name_bank_kard_2" field.
func (m *PaymentRequisiteMutation) ClearNameBankKard2() {
	m.name_bank_kard_2 = nil
	m.clearedFields[paymentrequisite.FieldNameBankKard2] = struct{}{}
}

// NameBankKard2Cleared returns if the "name_bank_kard_2" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) NameBankKard2Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldNameBankKard2]
	return ok
}

// ResetNameBankKard2 resets all changes to the "name_bank_kard_2" field.
func (m *PaymentRequisiteMutation) ResetNameBankKard2() {
	m.name_bank_kard_2 = nil
	delete(m.clearedFields, paymentrequisite.FieldNameBankKard2)
}

// SetNameBankKard3 sets the "name_bank_kard_3" field.
func (m *PaymentRequisiteMutation) SetNameBankKard3(s string) {
	m.name_bank_kard_3 = &s
}

// NameBankKard3 returns the value of the "name_bank_kard_3" field in the mutation.
func (m *PaymentRequisiteMutation) NameBankKard3() (r string, exists bool) {
	v := m.name_bank_kard_3
	if v == nil {
		return
	}
	return *v, true
}

// OldNameBankKard3 returns the old "name_bank_kard_3" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldNameBankKard3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameBankKard3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameBankKard3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameBankKard3: %w", err)
	}
	return oldValue.NameBankKard3, nil
}

// ClearNameBankKard3 clears the value of the "name_bank_kard_3" field.
func (m *PaymentRequisiteMutation) ClearNameBankKard3() {
	m.name_bank_kard_3 = nil
	m.clearedFields[paymentrequisite.FieldNameBankKard3] = struct{}{}
}

// NameBankKard3Cleared returns if the "name_bank_kard_3" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) NameBankKard3Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldNameBankKard3]
	return ok
}

// ResetNameBankKard3 resets all changes to the "name_bank_kard_3" field.
func (m *PaymentRequisiteMutation) ResetNameBankKard3() {
	m.name_bank_kard_3 = nil
	delete(m.clearedFields, paymentrequisite.FieldNameBankKard3)
}

// SetNameBankKard4 sets the "name_bank_kard_4" field.
func (m *PaymentRequisiteMutation) SetNameBankKard4(s string) {
	m.name_bank_kard_4 = &s
}

// NameBankKard4 returns the value of the "name_bank_kard_4" field in the mutation.
func (m *PaymentRequisiteMutation) NameBankKard4() (r string, exists bool) {
	v := m.name_bank_kard_4
	if v == nil {
		return
	}
	return *v, true
}

// OldNameBankKard4 returns the old "name_bank_kard_4" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldNameBankKard4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameBankKard4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameBankKard4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameBankKard4: %w", err)
	}
	return oldValue.NameBankKard4, nil
}

// ClearNameBankKard4 clears the value of the "name_bank_kard_4" field.
func (m *PaymentRequisiteMutation) ClearNameBankKard4() {
	m.name_bank_kard_4 = nil
	m.clearedFields[paymentrequisite.FieldNameBankKard4] = struct{}{}
}

// NameBankKard4Cleared returns if the "name_bank_kard_4" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) NameBankKard4Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldNameBankKard4]
	return ok
}

// ResetNameBankKard4 resets all changes to the "name_bank_kard_4" field.
func (m *PaymentRequisiteMutation) ResetNameBankKard4() {
	m.name_bank_kard_4 = nil
	delete(m.clearedFields, paymentrequisite.FieldNameBankKard4)
}

// SetNameBankKard5 sets the "name_bank_kard_5" field.
func (m *PaymentRequisiteMutation) SetNameBankKard5(s string) {
	m.name_bank_kard_5 = &s
}

// NameBankKard5 returns the value of the "name_bank_kard_5" field in the mutation.
func (m *PaymentRequisiteMutation) NameBankKard5() (r string, exists bool) {
	v := m.name_bank_kard_5
	if v == nil {
		return
	}
	return *v, true
}

// OldNameBankKard5 returns the old "name_bank_kard_5" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldNameBankKard5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameBankKard5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameBankKard5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameBankKard5: %w", err)
	}
	return oldValue.NameBankKard5, nil
}

// ClearNameBankKard5 clears the value of the "name_bank_kard_5" field.
func (m *PaymentRequisiteMutation) ClearNameBankKard5() {
	m.name_bank_kard_5 = nil
	m.clearedFields[paymentrequisite.FieldNameBankKard5] = struct{}{}
}

// NameBankKard5Cleared returns if the "name_bank_kard_5" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) NameBankKard5Cleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldNameBankKard5]
	return ok
}

// ResetNameBankKard5 resets all changes to the "name_bank_kard_5" field.
func (m *PaymentRequisiteMutation) ResetNameBankKard5() {
	m.name_bank_kard_5 = nil
	delete(m.clearedFields, paymentrequisite.FieldNameBankKard5)
}

// SetNameBank sets the "name_bank" field.
func (m *PaymentRequisiteMutation) SetNameBank(s string) {
	m.name_bank = &s
}

// NameBank returns the value of the "name_bank" field in the mutation.
func (m *PaymentRequisiteMutation) NameBank() (r string, exists bool) {
	v := m.name_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldNameBank returns the old "name_bank" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldNameBank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameBank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameBank: %w", err)
	}
	return oldValue.NameBank, nil
}

// ClearNameBank clears the value of the "name_bank" field.
func (m *PaymentRequisiteMutation) ClearNameBank() {
	m.name_bank = nil
	m.clearedFields[paymentrequisite.FieldNameBank] = struct{}{}
}

// NameBankCleared returns if the "name_bank" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) NameBankCleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldNameBank]
	return ok
}

// ResetNameBank resets all changes to the "name_bank" field.
func (m *PaymentRequisiteMutation) ResetNameBank() {
	m.name_bank = nil
	delete(m.clearedFields, paymentrequisite.FieldNameBank)
}

// SetIban sets the "iban" field.
func (m *PaymentRequisiteMutation) SetIban(s string) {
	m.iban = &s
}

// Iban returns the value of the "iban" field in the mutation.
func (m *PaymentRequisiteMutation) Iban() (r string, exists bool) {
	v := m.iban
	if v == nil {
		return
	}
	return *v, true
}

// OldIban returns the old "iban" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldIban(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIban is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIban requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIban: %w", err)
	}
	return oldValue.Iban, nil
}

// ClearIban clears the value of the "iban" field.
func (m *PaymentRequisiteMutation) ClearIban() {
	m.iban = nil
	m.clearedFields[paymentrequisite.FieldIban] = struct{}{}
}

// IbanCleared returns if the "iban" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) IbanCleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldIban]
	return ok
}

// ResetIban resets all changes to the "iban" field.
func (m *PaymentRequisiteMutation) ResetIban() {
	m.iban = nil
	delete(m.clearedFields, paymentrequisite.FieldIban)
}

// SetEdrpou sets the "edrpou" field.
func (m *PaymentRequisiteMutation) SetEdrpou(s string) {
	m.edrpou = &s
}

// Edrpou returns the value of the "edrpou" field in the mutation.
func (m *PaymentRequisiteMutation) Edrpou() (r string, exists bool) {
	v := m.edrpou
	if v == nil {
		return
	}
	return *v, true
}

// OldEdrpou returns the old "edrpou" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldEdrpou(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEdrpou is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEdrpou requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEdrpou: %w", err)
	}
	return oldValue.Edrpou, nil
}

// ClearEdrpou clears the value of the "edrpou" field.
func (m *PaymentRequisiteMutation) ClearEdrpou() {
	m.edrpou = nil
	m.clearedFields[paymentrequisite.FieldEdrpou] = struct{}{}
}

// EdrpouCleared returns if the "edrpou" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) EdrpouCleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldEdrpou]
	return ok
}

// ResetEdrpou resets all changes to the "edrpou" field.
func (m *PaymentRequisiteMutation) ResetEdrpou() {
	m.edrpou = nil
	delete(m.clearedFields, paymentrequisite.FieldEdrpou)
}

// SetReceiverName sets the "receiver_name" field.
func (m *PaymentRequisiteMutation) SetReceiverName(s string) {
	m.receiver_name = &s
}

// ReceiverName returns the value of the "receiver_name" field in the mutation.
func (m *PaymentRequisiteMutation) ReceiverName() (r string, exists bool) {
	v := m.receiver_name
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverName returns the old "receiver_name" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldReceiverName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverName: %w", err)
	}
	return oldValue.ReceiverName, nil
}

// ClearReceiverName clears the value of the "receiver_name" field.
func (m *PaymentRequisiteMutation) ClearReceiverName() {
	m.receiver_name = nil
	m.clearedFields[paymentrequisite.FieldReceiverName] = struct{}{}
}

// ReceiverNameCleared returns if the "receiver_name" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) ReceiverNameCleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldReceiverName]
	return ok
}

// ResetReceiverName resets all changes to the "receiver_name" field.
func (m *PaymentRequisiteMutation) ResetReceiverName() {
	m.receiver_name = nil
	delete(m.clearedFields, paymentrequisite.FieldReceiverName)
}

// SetPaymentPurpose sets the "payment_purpose" field.
func (m *PaymentRequisiteMutation) SetPaymentPurpose(s string) {
	m.payment_purpose = &s
}

// PaymentPurpose returns the value of the "payment_purpose" field in the mutation.
func (m *PaymentRequisiteMutation) PaymentPurpose() (r string, exists bool) {
	v := m.payment_purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentPurpose returns the old "payment_purpose" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldPaymentPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentPurpose: %w", err)
	}
	return oldValue.PaymentPurpose, nil
}

// ClearPaymentPurpose clears the value of the "payment_purpose" field.
func (m *PaymentRequisiteMutation) ClearPaymentPurpose() {
	m.payment_purpose = nil
	m.clearedFields[paymentrequisite.FieldPaymentPurpose] = struct{}{}
}

// PaymentPurposeCleared returns if the "payment_purpose" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) PaymentPurposeCleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldPaymentPurpose]
	return ok
}

// ResetPaymentPurpose resets all changes to the "payment_purpose" field.
func (m *PaymentRequisiteMutation) ResetPaymentPurpose() {
	m.payment_purpose = nil
	delete(m.clearedFields, paymentrequisite.FieldPaymentPurpose)
}

// SetMfo sets the "mfo" field.
func (m *PaymentRequisiteMutation) SetMfo(s string) {
	m.mfo = &s
}

// Mfo returns the value of the "mfo" field in the mutation.
func (m *PaymentRequisiteMutation) Mfo() (r string, exists bool) {
	v := m.mfo
	if v == nil {
		return
	}
	return *v, true
}

// OldMfo returns the old "mfo" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldMfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfo: %w", err)
	}
	return oldValue.Mfo, nil
}

// ClearMfo clears the value of the "mfo" field.
func (m *PaymentRequisiteMutation) ClearMfo() {
	m.mfo = nil
	m.clearedFields[paymentrequisite.FieldMfo] = struct{}{}
}

// MfoCleared returns if the "mfo" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) MfoCleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldMfo]
	return ok
}

// ResetMfo resets all changes to the "mfo" field.
func (m *PaymentRequisiteMutation) ResetMfo() {
	m.mfo = nil
	delete(m.clearedFields, paymentrequisite.FieldMfo)
}

// SetAccountNumber sets the "account_number" field.
func (m *PaymentRequisiteMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *PaymentRequisiteMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the PaymentRequisite entity.
// If the PaymentRequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentRequisiteMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ClearAccountNumber clears the value of the "account_number" field.
func (m *PaymentRequisiteMutation) ClearAccountNumber() {
	m.account_number = nil
	m.clearedFields[paymentrequisite.FieldAccountNumber] = struct{}{}
}

// AccountNumberCleared returns if the "account_number" field was cleared in this mutation.
func (m *PaymentRequisiteMutation) AccountNumberCleared() bool {
	_, ok := m.clearedFields[paymentrequisite.FieldAccountNumber]
	return ok
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *PaymentRequisiteMutation) ResetAccountNumber() {
	m.account_number = nil
	delete(m.clearedFields, paymentrequisite.FieldAccountNumber)
}

// SetGymID sets the "gym" edge to the Gym entity by id.
func (m *PaymentRequisiteMutation) SetGymID(id int) {
	m.gym = &id
}

// ClearGym clears the "gym" edge to the Gym entity.
func (m *PaymentRequisiteMutation) ClearGym() {
	m.clearedgym = true
}

// GymCleared reports if the "gym" edge to the Gym entity was cleared.
func (m *PaymentRequisiteMutation) GymCleared() bool {
	return m.clearedgym
}

// GymID returns the "gym" edge ID in the mutation.
func (m *PaymentRequisiteMutation) GymID() (id int, exists bool) {
	if m.gym != nil {
		return *m.gym, true
	}
	return
}

// GymIDs returns the "gym" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GymID instead. It exists only for internal usage by the builders.
func (m *PaymentRequisiteMutation) GymIDs() (ids []int) {
	if id := m.gym; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGym resets all changes to the "gym" edge.
func (m *PaymentRequisiteMutation) ResetGym() {
	m.gym = nil
	m.clearedgym = false
}

// Where appends a list predicates to the PaymentRequisiteMutation builder.
func (m *PaymentRequisiteMutation) Where(ps ...predicate.PaymentRequisite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentRequisiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentRequisiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentRequisite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentRequisiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentRequisiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentRequisite).
func (m *PaymentRequisiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentRequisiteMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.bank_kard_1 != nil {
		fields = append(fields, paymentrequisite.FieldBankKard1)
	}
	if m.bank_kard_2 != nil {
		fields = append(fields, paymentrequisite.FieldBankKard2)
	}
	if m.bank_kard_3 != nil {
		fields = append(fields, paymentrequisite.FieldBankKard3)
	}
	if m.bank_kard_4 != nil {
		fields = append(fields, paymentrequisite.FieldBankKard4)
	}
	if m.bank_kard_5 != nil {
		fields = append(fields, paymentrequisite.FieldBankKard5)
	}
	if m.name_bank_kard_1 != nil {
		fields = append(fields, paymentrequisite.FieldNameBankKard1)
	}
	if m.name_bank_kard_2 != nil {
		fields = append(fields, paymentrequisite.FieldNameBankKard2)
	}
	if m.name_bank_kard_3 != nil {
		fields = append(fields, paymentrequisite.FieldNameBankKard3)
	}
	if m.name_bank_kard_4 != nil {
		fields = append(fields, paymentrequisite.FieldNameBankKard4)
	}
	if m.name_bank_kard_5 != nil {
		fields = append(fields, paymentrequisite.FieldNameBankKard5)
	}
	if m.name_bank != nil {
		fields = append(fields, paymentrequisite.FieldNameBank)
	}
	if m.iban != nil {
		fields = append(fields, paymentrequisite.FieldIban)
	}
	if m.edrpou != nil {
		fields = append(fields, paymentrequisite.FieldEdrpou)
	}
	if m.receiver_name != nil {
		fields = append(fields, paymentrequisite.FieldReceiverName)
	}
	if m.payment_purpose != nil {
		fields = append(fields, paymentrequisite.FieldPaymentPurpose)
	}
	if m.mfo != nil {
		fields = append(fields, paymentrequisite.FieldMfo)
	}
	if m.account_number != nil {
		fields = append(fields, paymentrequisite.FieldAccountNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentRequisiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentrequisite.FieldBankKard1:
		return m.BankKard1()
	case paymentrequisite.FieldBankKard2:
		return m.BankKard2()
	case paymentrequisite.FieldBankKard3:
		return m.BankKard3()
	case paymentrequisite.FieldBankKard4:
		return m.BankKard4()
	case paymentrequisite.FieldBankKard5:
		return m.BankKard5()
	case paymentrequisite.FieldNameBankKard1:
		return m.NameBankKard1()
	case paymentrequisite.FieldNameBankKard2:
		return m.NameBankKard2()
	case paymentrequisite.FieldNameBankKard3:
		return m.NameBankKard3()
	case paymentrequisite.FieldNameBankKard4:
		return m.NameBankKard4()
	case paymentrequisite.FieldNameBankKard5:
		return m.NameBankKard5()
	case paymentrequisite.FieldNameBank:
		return m.NameBank()
	case paymentrequisite.FieldIban:
		return m.Iban()
	case paymentrequisite.FieldEdrpou:
		return m.Edrpou()
	case paymentrequisite.FieldReceiverName:
		return m.ReceiverName()
	case paymentrequisite.FieldPaymentPurpose:
		return m.PaymentPurpose()
	case paymentrequisite.FieldMfo:
		return m.Mfo()
	case paymentrequisite.FieldAccountNumber:
		return m.AccountNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentRequisiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentrequisite.FieldBankKard1:
		return m.OldBankKard1(ctx)
	case paymentrequisite.FieldBankKard2:
		return m.OldBankKard2(ctx)
	case paymentrequisite.FieldBankKard3:
		return m.OldBankKard3(ctx)
	case paymentrequisite.FieldBankKard4:
		return m.OldBankKard4(ctx)
	case paymentrequisite.FieldBankKard5:
		return m.OldBankKard5(ctx)
	case paymentrequisite.FieldNameBankKard1:
		return m.OldNameBankKard1(ctx)
	case paymentrequisite.FieldNameBankKard2:
		return m.OldNameBankKard2(ctx)
	case paymentrequisite.FieldNameBankKard3:
		return m.OldNameBankKard3(ctx)
	case paymentrequisite.FieldNameBankKard4:
		return m.OldNameBankKard4(ctx)
	case paymentrequisite.FieldNameBankKard5:
		return m.OldNameBankKard5(ctx)
	case paymentrequisite.FieldNameBank:
		return m.OldNameBank(ctx)
	case paymentrequisite.FieldIban:
		return m.OldIban(ctx)
	case paymentrequisite.FieldEdrpou:
		return m.OldEdrpou(ctx)
	case paymentrequisite.FieldReceiverName:
		return m.OldReceiverName(ctx)
	case paymentrequisite.FieldPaymentPurpose:
		return m.OldPaymentPurpose(ctx)
	case paymentrequisite.FieldMfo:
		return m.OldMfo(ctx)
	case paymentrequisite.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentRequisite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentRequisiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentrequisite.FieldBankKard1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankKard1(v)
		return nil
	case paymentrequisite.FieldBankKard2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankKard2(v)
		return nil
	case paymentrequisite.FieldBankKard3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankKard3(v)
		return nil
	case paymentrequisite.FieldBankKard4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankKard4(v)
		return nil
	case paymentrequisite.FieldBankKard5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankKard5(v)
		return nil
	case paymentrequisite.FieldNameBankKard1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameBankKard1(v)
		return nil
	case paymentrequisite.FieldNameBankKard2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameBankKard2(v)
		return nil
	case paymentrequisite.FieldNameBankKard3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameBankKard3(v)
		return nil
	case paymentrequisite.FieldNameBankKard4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameBankKard4(v)
		return nil
	case paymentrequisite.FieldNameBankKard5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameBankKard5(v)
		return nil
	case paymentrequisite.FieldNameBank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameBank(v)
		return nil
	case paymentrequisite.FieldIban:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIban(v)
		return nil
	case paymentrequisite.FieldEdrpou:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEdrpou(v)
		return nil
	case paymentrequisite.FieldReceiverName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverName(v)
		return nil
	case paymentrequisite.FieldPaymentPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentPurpose(v)
		return nil
	case paymentrequisite.FieldMfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfo(v)
		return nil
	case paymentrequisite.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentRequisite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentRequisiteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentRequisiteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentRequisiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentRequisite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentRequisiteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentrequisite.FieldBankKard1) {
		fields = append(fields, paymentrequisite.FieldBankKard1)
	}
	if m.FieldCleared(paymentrequisite.FieldBankKard2) {
		fields = append(fields, paymentrequisite.FieldBankKard2)
	}
	if m.FieldCleared(paymentrequisite.FieldBankKard3) {
		fields = append(fields, paymentrequisite.FieldBankKard3)
	}
	if m.FieldCleared(paymentrequisite.FieldBankKard4) {
		fields = append(fields, paymentrequisite.FieldBankKard4)
	}
	if m.FieldCleared(paymentrequisite.FieldBankKard5) {
		fields = append(fields, paymentrequisite.FieldBankKard5)
	}
	if m.FieldCleared(paymentrequisite.FieldNameBankKard1) {
		fields = append(fields, paymentrequisite.FieldNameBankKard1)
	}
	if m.FieldCleared(paymentrequisite.FieldNameBankKard2) {
		fields = append(fields, paymentrequisite.FieldNameBankKard2)
	}
	if m.FieldCleared(paymentrequisite.FieldNameBankKard3) {
		fields = append(fields, paymentrequisite.FieldNameBankKard3)
	}
	if m.FieldCleared(paymentrequisite.FieldNameBankKard4) {
		fields = append(fields, paymentrequisite.FieldNameBankKard4)
	}
	if m.FieldCleared(paymentrequisite.FieldNameBankKard5) {
		fields = append(fields, paymentrequisite.FieldNameBankKard5)
	}
	if m.FieldCleared(paymentrequisite.FieldNameBank) {
		fields = append(fields, paymentrequisite.FieldNameBank)
	}
	if m.FieldCleared(paymentrequisite.FieldIban) {
		fields = append(fields, paymentrequisite.FieldIban)
	}
	if m.FieldCleared(paymentrequisite.FieldEdrpou) {
		fields = append(fields, paymentrequisite.FieldEdrpou)
	}
	if m.FieldCleared(paymentrequisite.FieldReceiverName) {
		fields = append(fields, paymentrequisite.FieldReceiverName)
	}
	if m.FieldCleared(paymentrequisite.FieldPaymentPurpose) {
		fields = append(fields, paymentrequisite.FieldPaymentPurpose)
	}
	if m.FieldCleared(paymentrequisite.FieldMfo) {
		fields = append(fields, paymentrequisite.FieldMfo)
	}
	if m.FieldCleared(paymentrequisite.FieldAccountNumber) {
		fields = append(fields, paymentrequisite.FieldAccountNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentRequisiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentRequisiteMutation) ClearField(name string) error {
	switch name {
	case paymentrequisite.FieldBankKard1:
		m.ClearBankKard1()
		return nil
	case paymentrequisite.FieldBankKard2:
		m.ClearBankKard2()
		return nil
	case paymentrequisite.FieldBankKard3:
		m.ClearBankKard3()
		return nil
	case paymentrequisite.FieldBankKard4:
		m.ClearBankKard4()
		return nil
	case paymentrequisite.FieldBankKard5:
		m.ClearBankKard5()
		return nil
	case paymentrequisite.FieldNameBankKard1:
		m.ClearNameBankKard1()
		return nil
	case paymentrequisite.FieldNameBankKard2:
		m.ClearNameBankKard2()
		return nil
	case paymentrequisite.FieldNameBankKard3:
		m.ClearNameBankKard3()
		return nil
	case paymentrequisite.FieldNameBankKard4:
		m.ClearNameBankKard4()
		return nil
	case paymentrequisite.FieldNameBankKard5:
		m.ClearNameBankKard5()
		return nil
	case paymentrequisite.FieldNameBank:
		m.ClearNameBank()
		return nil
	case paymentrequisite.FieldIban:
		m.ClearIban()
		return nil
	case paymentrequisite.FieldEdrpou:
		m.ClearEdrpou()
		return nil
	case paymentrequisite.FieldReceiverName:
		m.ClearReceiverName()
		return nil
	case paymentrequisite.FieldPaymentPurpose:
		m.ClearPaymentPurpose()
		return nil
	case paymentrequisite.FieldMfo:
		m.ClearMfo()
		return nil
	case paymentrequisite.FieldAccountNumber:
		m.ClearAccountNumber()
		return nil
	}
	return fmt.Errorf("unknown PaymentRequisite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentRequisiteMutation) ResetField(name string) error {
	switch name {
	case paymentrequisite.FieldBankKard1:
		m.ResetBankKard1()
		return nil
	case paymentrequisite.FieldBankKard2:
		m.ResetBankKard2()
		return nil
	case paymentrequisite.FieldBankKard3:
		m.ResetBankKard3()
		return nil
	case paymentrequisite.FieldBankKard4:
		m.ResetBankKard4()
		return nil
	case paymentrequisite.FieldBankKard5:
		m.ResetBankKard5()
		return nil
	case paymentrequisite.FieldNameBankKard1:
		m.ResetNameBankKard1()
		return nil
	case paymentrequisite.FieldNameBankKard2:
		m.ResetNameBankKard2()
		return nil
	case paymentrequisite.FieldNameBankKard3:
		m.ResetNameBankKard3()
		return nil
	case paymentrequisite.FieldNameBankKard4:
		m.ResetNameBankKard4()
		return nil
	case paymentrequisite.FieldNameBankKard5:
		m.ResetNameBankKard5()
		return nil
	case paymentrequisite.FieldNameBank:
		m.ResetNameBank()
		return nil
	case paymentrequisite.FieldIban:
		m.ResetIban()
		return nil
	case paymentrequisite.FieldEdrpou:
		m.ResetEdrpou()
		return nil
	case paymentrequisite.FieldReceiverName:
		m.ResetReceiverName()
		return nil
	case paymentrequisite.FieldPaymentPurpose:
		m.ResetPaymentPurpose()
		return nil
	case paymentrequisite.FieldMfo:
		m.ResetMfo()
		return nil
	case paymentrequisite.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	}
	return fmt.Errorf("unknown PaymentRequisite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentRequisiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.gym != nil {
		edges = append(edges, paymentrequisite.EdgeGym)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentRequisiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentrequisite.EdgeGym:
		if id := m.gym; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentRequisiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentRequisiteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentRequisiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgym {
		edges = append(edges, paymentrequisite.EdgeGym)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentRequisiteMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentrequisite.EdgeGym:
		return m.clearedgym
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentRequisiteMutation) ClearEdge(name string) error {
	switch name {
	case paymentrequisite.EdgeGym:
		m.ClearGym()
		return nil
	}
	return fmt.Errorf("unknown PaymentRequisite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentRequisiteMutation) ResetEdge(name string) error {
	switch name {
	case paymentrequisite.EdgeGym:
		m.ResetGym()
		return nil
	}
	return fmt.Errorf("unknown PaymentRequisite edge %s", name)
}

// UsageModeMutation represents an operation that mutates the UsageMode nodes in the graph.
type UsageModeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	mode              *usagemode.Mode
	created_at        *time.Time
	paid_activated_at *time.Time
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*UsageMode, error)
	predicates        []predicate.UsageMode
}

var _ ent.Mutation = (*UsageModeMutation)(nil)

// usagemodeOption allows management of the mutation configuration using functional options.
type usagemodeOption func(*UsageModeMutation)

// newUsageModeMutation creates new mutation for the UsageMode entity.
func newUsageModeMutation(c config, op Op, opts ...usagemodeOption) *UsageModeMutation {
	m := &UsageModeMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageMode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageModeID sets the ID field of the mutation.
func withUsageModeID(id int) usagemodeOption {
	return func(m *UsageModeMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageMode
		)
		m.oldValue = func(ctx context.Context) (*UsageMode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageMode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageMode sets the old UsageMode of the mutation.
func withUsageMode(node *UsageMode) usagemodeOption {
	return func(m *UsageModeMutation) {
		m.oldValue = func(context.Context) (*UsageMode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageModeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageModeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageModeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageModeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageMode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMode sets the "mode" field.
func (m *UsageModeMutation) SetMode(u usagemode.Mode) {
	m.mode = &u
}

// Mode returns the value of the "mode" field in the mutation.
func (m *UsageModeMutation) Mode() (r usagemode.Mode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the UsageMode entity.
// If the UsageMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageModeMutation) OldMode(ctx context.Context) (v usagemode.Mode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *UsageModeMutation) ResetMode() {
	m.mode = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageModeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageModeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageMode entity.
// If the UsageMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageModeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageModeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPaidActivatedAt sets the "paid_activated_at" field.
func (m *UsageModeMutation) SetPaidActivatedAt(t time.Time) {
	m.paid_activated_at = &t
}

// PaidActivatedAt returns the value of the "paid_activated_at" field in the mutation.
func (m *UsageModeMutation) PaidActivatedAt() (r time.Time, exists bool) {
	v := m.paid_activated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidActivatedAt returns the old "paid_activated_at" field's value of the UsageMode entity.
// If the UsageMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageModeMutation) OldPaidActivatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidActivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidActivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidActivatedAt: %w", err)
	}
	return oldValue.PaidActivatedAt, nil
}

// ClearPaidActivatedAt clears the value of the "paid_activated_at" field.
func (m *UsageModeMutation) ClearPaidActivatedAt() {
	m.paid_activated_at = nil
	m.clearedFields[usagemode.FieldPaidActivatedAt] = struct{}{}
}

// PaidActivatedAtCleared returns if the "paid_activated_at" field was cleared in this mutation.
func (m *UsageModeMutation) PaidActivatedAtCleared() bool {
	_, ok := m.clearedFields[usagemode.FieldPaidActivatedAt]
	return ok
}

// ResetPaidActivatedAt resets all changes to the "paid_activated_at" field.
func (m *UsageModeMutation) ResetPaidActivatedAt() {
	m.paid_activated_at = nil
	delete(m.clearedFields, usagemode.FieldPaidActivatedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UsageModeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UsageModeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UsageModeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UsageModeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UsageModeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UsageModeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UsageModeMutation builder.
func (m *UsageModeMutation) Where(ps ...predicate.UsageMode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageModeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageModeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageMode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageModeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageModeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageMode).
func (m *UsageModeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageModeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.mode != nil {
		fields = append(fields, usagemode.FieldMode)
	}
	if m.created_at != nil {
		fields = append(fields, usagemode.FieldCreatedAt)
	}
	if m.paid_activated_at != nil {
		fields = append(fields, usagemode.FieldPaidActivatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageModeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagemode.FieldMode:
		return m.Mode()
	case usagemode.FieldCreatedAt:
		return m.CreatedAt()
	case usagemode.FieldPaidActivatedAt:
		return m.PaidActivatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageModeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagemode.FieldMode:
		return m.OldMode(ctx)
	case usagemode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagemode.FieldPaidActivatedAt:
		return m.OldPaidActivatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UsageMode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageModeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagemode.FieldMode:
		v, ok := value.(usagemode.Mode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case usagemode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagemode.FieldPaidActivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidActivatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UsageMode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageModeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageModeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageModeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsageMode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageModeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagemode.FieldPaidActivatedAt) {
		fields = append(fields, usagemode.FieldPaidActivatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageModeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageModeMutation) ClearField(name string) error {
	switch name {
	case usagemode.FieldPaidActivatedAt:
		m.ClearPaidActivatedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageMode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageModeMutation) ResetField(name string) error {
	switch name {
	case usagemode.FieldMode:
		m.ResetMode()
		return nil
	case usagemode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagemode.FieldPaidActivatedAt:
		m.ResetPaidActivatedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageMode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageModeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usagemode.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageModeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagemode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageModeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageModeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageModeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usagemode.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageModeMutation) EdgeCleared(name string) bool {
	switch name {
	case usagemode.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageModeMutation) ClearEdge(name string) error {
	switch name {
	case usagemode.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UsageMode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageModeMutation) ResetEdge(name string) error {
	switch name {
	case usagemode.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UsageMode edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	mail                    *string
	first_name              *string
	last_name               *string
	phone                   *string
	address                 *string
	description             *string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	visitor_gym             map[int]struct{}
	removedvisitor_gym      map[int]struct{}
	clearedvisitor_gym      bool
	manager_gym             map[int]struct{}
	removedmanager_gym      map[int]struct{}
	clearedmanager_gym      bool
	personal_treiner        map[int]struct{}
	removedpersonal_treiner map[int]struct{}
	clearedpersonal_treiner bool
	owned_gyms              map[int]struct{}
	removedowned_gyms       map[int]struct{}
	clearedowned_gyms       bool
	abonements              map[int]struct{}
	removedabonements       map[int]struct{}
	clearedabonements       bool
	user_roles              map[int]struct{}
	removeduser_roles       map[int]struct{}
	cleareduser_roles       bool
	manager_roles           map[int]struct{}
	removedmanager_roles    map[int]struct{}
	clearedmanager_roles    bool
	family_of               map[int]struct{}
	removedfamily_of        map[int]struct{}
	clearedfamily_of        bool
	family_members          map[int]struct{}
	removedfamily_members   map[int]struct{}
	clearedfamily_members   bool
	credential              *int
	clearedcredential       bool
	usage_mode              *int
	clearedusage_mode       bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMail sets the "mail" field.
func (m *UserMutation) SetMail(s string) {
	m.mail = &s
}

// Mail returns the value of the "mail" field in the mutation.
func (m *UserMutation) Mail() (r string, exists bool) {
	v := m.mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "mail" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ResetMail resets all changes to the "mail" field.
func (m *UserMutation) ResetMail() {
	m.mail = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *UserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[user.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *UserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[user.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, user.FieldAddress)
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[user.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[user.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, user.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// AddVisitorGymIDs adds the "visitor_gym" edge to the Gym entity by ids.
func (m *UserMutation) AddVisitorGymIDs(ids ...int) {
	if m.visitor_gym == nil {
		m.visitor_gym = make(map[int]struct{})
	}
	for i := range ids {
		m.visitor_gym[ids[i]] = struct{}{}
	}
}

// ClearVisitorGym clears the "visitor_gym" edge to the Gym entity.
func (m *UserMutation) ClearVisitorGym() {
	m.clearedvisitor_gym = true
}

// VisitorGymCleared reports if the "visitor_gym" edge to the Gym entity was cleared.
func (m *UserMutation) VisitorGymCleared() bool {
	return m.clearedvisitor_gym
}

// RemoveVisitorGymIDs removes the "visitor_gym" edge to the Gym entity by IDs.
func (m *UserMutation) RemoveVisitorGymIDs(ids ...int) {
	if m.removedvisitor_gym == nil {
		m.removedvisitor_gym = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.visitor_gym, ids[i])
		m.removedvisitor_gym[ids[i]] = struct{}{}
	}
}

// RemovedVisitorGym returns the removed IDs of the "visitor_gym" edge to the Gym entity.
func (m *UserMutation) RemovedVisitorGymIDs() (ids []int) {
	for id := range m.removedvisitor_gym {
		ids = append(ids, id)
	}
	return
}

// VisitorGymIDs returns the "visitor_gym" edge IDs in the mutation.
func (m *UserMutation) VisitorGymIDs() (ids []int) {
	for id := range m.visitor_gym {
		ids = append(ids, id)
	}
	return
}

// ResetVisitorGym resets all changes to the "visitor_gym" edge.
func (m *UserMutation) ResetVisitorGym() {
	m.visitor_gym = nil
	m.clearedvisitor_gym = false
	m.removedvisitor_gym = nil
}

// AddManagerGymIDs adds the "manager_gym" edge to the Gym entity by ids.
func (m *UserMutation) AddManagerGymIDs(ids ...int) {
	if m.manager_gym == nil {
		m.manager_gym = make(map[int]struct{})
	}
	for i := range ids {
		m.manager_gym[ids[i]] = struct{}{}
	}
}

// ClearManagerGym clears the "manager_gym" edge to the Gym entity.
func (m *UserMutation) ClearManagerGym() {
	m.clearedmanager_gym = true
}

// ManagerGymCleared reports if the "manager_gym" edge to the Gym entity was cleared.
func (m *UserMutation) ManagerGymCleared() bool {
	return m.clearedmanager_gym
}

// RemoveManagerGymIDs removes the "manager_gym" edge to the Gym entity by IDs.
func (m *UserMutation) RemoveManagerGymIDs(ids ...int) {
	if m.removedmanager_gym == nil {
		m.removedmanager_gym = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.manager_gym, ids[i])
		m.removedmanager_gym[ids[i]] = struct{}{}
	}
}

// RemovedManagerGym returns the removed IDs of the "manager_gym" edge to the Gym entity.
func (m *UserMutation) RemovedManagerGymIDs() (ids []int) {
	for id := range m.removedmanager_gym {
		ids = append(ids, id)
	}
	return
}

// ManagerGymIDs returns the "manager_gym" edge IDs in the mutation.
func (m *UserMutation) ManagerGymIDs() (ids []int) {
	for id := range m.manager_gym {
		ids = append(ids, id)
	}
	return
}

// ResetManagerGym resets all changes to the "manager_gym" edge.
func (m *UserMutation) ResetManagerGym() {
	m.manager_gym = nil
	m.clearedmanager_gym = false
	m.removedmanager_gym = nil
}

// AddPersonalTreinerIDs adds the "personal_treiner" edge to the Abonement entity by ids.
func (m *UserMutation) AddPersonalTreinerIDs(ids ...int) {
	if m.personal_treiner == nil {
		m.personal_treiner = make(map[int]struct{})
	}
	for i := range ids {
		m.personal_treiner[ids[i]] = struct{}{}
	}
}

// ClearPersonalTreiner clears the "personal_treiner" edge to the Abonement entity.
func (m *UserMutation) ClearPersonalTreiner() {
	m.clearedpersonal_treiner = true
}

// PersonalTreinerCleared reports if the "personal_treiner" edge to the Abonement entity was cleared.
func (m *UserMutation) PersonalTreinerCleared() bool {
	return m.clearedpersonal_treiner
}

// RemovePersonalTreinerIDs removes the "personal_treiner" edge to the Abonement entity by IDs.
func (m *UserMutation) RemovePersonalTreinerIDs(ids ...int) {
	if m.removedpersonal_treiner == nil {
		m.removedpersonal_treiner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.personal_treiner, ids[i])
		m.removedpersonal_treiner[ids[i]] = struct{}{}
	}
}

// RemovedPersonalTreiner returns the removed IDs of the "personal_treiner" edge to the Abonement entity.
func (m *UserMutation) RemovedPersonalTreinerIDs() (ids []int) {
	for id := range m.removedpersonal_treiner {
		ids = append(ids, id)
	}
	return
}

// PersonalTreinerIDs returns the "personal_treiner" edge IDs in the mutation.
func (m *UserMutation) PersonalTreinerIDs() (ids []int) {
	for id := range m.personal_treiner {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalTreiner resets all changes to the "personal_treiner" edge.
func (m *UserMutation) ResetPersonalTreiner() {
	m.personal_treiner = nil
	m.clearedpersonal_treiner = false
	m.removedpersonal_treiner = nil
}

// AddOwnedGymIDs adds the "owned_gyms" edge to the Gym entity by ids.
func (m *UserMutation) AddOwnedGymIDs(ids ...int) {
	if m.owned_gyms == nil {
		m.owned_gyms = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_gyms[ids[i]] = struct{}{}
	}
}

// ClearOwnedGyms clears the "owned_gyms" edge to the Gym entity.
func (m *UserMutation) ClearOwnedGyms() {
	m.clearedowned_gyms = true
}

// OwnedGymsCleared reports if the "owned_gyms" edge to the Gym entity was cleared.
func (m *UserMutation) OwnedGymsCleared() bool {
	return m.clearedowned_gyms
}

// RemoveOwnedGymIDs removes the "owned_gyms" edge to the Gym entity by IDs.
func (m *UserMutation) RemoveOwnedGymIDs(ids ...int) {
	if m.removedowned_gyms == nil {
		m.removedowned_gyms = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owned_gyms, ids[i])
		m.removedowned_gyms[ids[i]] = struct{}{}
	}
}

// RemovedOwnedGyms returns the removed IDs of the "owned_gyms" edge to the Gym entity.
func (m *UserMutation) RemovedOwnedGymsIDs() (ids []int) {
	for id := range m.removedowned_gyms {
		ids = append(ids, id)
	}
	return
}

// OwnedGymsIDs returns the "owned_gyms" edge IDs in the mutation.
func (m *UserMutation) OwnedGymsIDs() (ids []int) {
	for id := range m.owned_gyms {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedGyms resets all changes to the "owned_gyms" edge.
func (m *UserMutation) ResetOwnedGyms() {
	m.owned_gyms = nil
	m.clearedowned_gyms = false
	m.removedowned_gyms = nil
}

// AddAbonementIDs adds the "abonements" edge to the Abonement entity by ids.
func (m *UserMutation) AddAbonementIDs(ids ...int) {
	if m.abonements == nil {
		m.abonements = make(map[int]struct{})
	}
	for i := range ids {
		m.abonements[ids[i]] = struct{}{}
	}
}

// ClearAbonements clears the "abonements" edge to the Abonement entity.
func (m *UserMutation) ClearAbonements() {
	m.clearedabonements = true
}

// AbonementsCleared reports if the "abonements" edge to the Abonement entity was cleared.
func (m *UserMutation) AbonementsCleared() bool {
	return m.clearedabonements
}

// RemoveAbonementIDs removes the "abonements" edge to the Abonement entity by IDs.
func (m *UserMutation) RemoveAbonementIDs(ids ...int) {
	if m.removedabonements == nil {
		m.removedabonements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.abonements, ids[i])
		m.removedabonements[ids[i]] = struct{}{}
	}
}

// RemovedAbonements returns the removed IDs of the "abonements" edge to the Abonement entity.
func (m *UserMutation) RemovedAbonementsIDs() (ids []int) {
	for id := range m.removedabonements {
		ids = append(ids, id)
	}
	return
}

// AbonementsIDs returns the "abonements" edge IDs in the mutation.
func (m *UserMutation) AbonementsIDs() (ids []int) {
	for id := range m.abonements {
		ids = append(ids, id)
	}
	return
}

// ResetAbonements resets all changes to the "abonements" edge.
func (m *UserMutation) ResetAbonements() {
	m.abonements = nil
	m.clearedabonements = false
	m.removedabonements = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...int) {
	if m.user_roles == nil {
		m.user_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...int) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []int) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []int) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddManagerRoleIDs adds the "manager_roles" edge to the ManagerRole entity by ids.
func (m *UserMutation) AddManagerRoleIDs(ids ...int) {
	if m.manager_roles == nil {
		m.manager_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.manager_roles[ids[i]] = struct{}{}
	}
}

// ClearManagerRoles clears the "manager_roles" edge to the ManagerRole entity.
func (m *UserMutation) ClearManagerRoles() {
	m.clearedmanager_roles = true
}

// ManagerRolesCleared reports if the "manager_roles" edge to the ManagerRole entity was cleared.
func (m *UserMutation) ManagerRolesCleared() bool {
	return m.clearedmanager_roles
}

// RemoveManagerRoleIDs removes the "manager_roles" edge to the ManagerRole entity by IDs.
func (m *UserMutation) RemoveManagerRoleIDs(ids ...int) {
	if m.removedmanager_roles == nil {
		m.removedmanager_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.manager_roles, ids[i])
		m.removedmanager_roles[ids[i]] = struct{}{}
	}
}

// RemovedManagerRoles returns the removed IDs of the "manager_roles" edge to the ManagerRole entity.
func (m *UserMutation) RemovedManagerRolesIDs() (ids []int) {
	for id := range m.removedmanager_roles {
		ids = append(ids, id)
	}
	return
}

// ManagerRolesIDs returns the "manager_roles" edge IDs in the mutation.
func (m *UserMutation) ManagerRolesIDs() (ids []int) {
	for id := range m.manager_roles {
		ids = append(ids, id)
	}
	return
}

// ResetManagerRoles resets all changes to the "manager_roles" edge.
func (m *UserMutation) ResetManagerRoles() {
	m.manager_roles = nil
	m.clearedmanager_roles = false
	m.removedmanager_roles = nil
}

// AddFamilyOfIDs adds the "family_of" edge to the User entity by ids.
func (m *UserMutation) AddFamilyOfIDs(ids ...int) {
	if m.family_of == nil {
		m.family_of = make(map[int]struct{})
	}
	for i := range ids {
		m.family_of[ids[i]] = struct{}{}
	}
}

// ClearFamilyOf clears the "family_of" edge to the User entity.
func (m *UserMutation) ClearFamilyOf() {
	m.clearedfamily_of = true
}

// FamilyOfCleared reports if the "family_of" edge to the User entity was cleared.
func (m *UserMutation) FamilyOfCleared() bool {
	return m.clearedfamily_of
}

// RemoveFamilyOfIDs removes the "family_of" edge to the User entity by IDs.
func (m *UserMutation) RemoveFamilyOfIDs(ids ...int) {
	if m.removedfamily_of == nil {
		m.removedfamily_of = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.family_of, ids[i])
		m.removedfamily_of[ids[i]] = struct{}{}
	}
}

// RemovedFamilyOf returns the removed IDs of the "family_of" edge to the User entity.
func (m *UserMutation) RemovedFamilyOfIDs() (ids []int) {
	for id := range m.removedfamily_of {
		ids = append(ids, id)
	}
	return
}

// FamilyOfIDs returns the "family_of" edge IDs in the mutation.
func (m *UserMutation) FamilyOfIDs() (ids []int) {
	for id := range m.family_of {
		ids = append(ids, id)
	}
	return
}

// ResetFamilyOf resets all changes to the "family_of" edge.
func (m *UserMutation) ResetFamilyOf() {
	m.family_of = nil
	m.clearedfamily_of = false
	m.removedfamily_of = nil
}

// AddFamilyMemberIDs adds the "family_members" edge to the User entity by ids.
func (m *UserMutation) AddFamilyMemberIDs(ids ...int) {
	if m.family_members == nil {
		m.family_members = make(map[int]struct{})
	}
	for i := range ids {
		m.family_members[ids[i]] = struct{}{}
	}
}

// ClearFamilyMembers clears the "family_members" edge to the User entity.
func (m *UserMutation) ClearFamilyMembers() {
	m.clearedfamily_members = true
}

// FamilyMembersCleared reports if the "family_members" edge to the User entity was cleared.
func (m *UserMutation) FamilyMembersCleared() bool {
	return m.clearedfamily_members
}

// RemoveFamilyMemberIDs removes the "family_members" edge to the User entity by IDs.
func (m *UserMutation) RemoveFamilyMemberIDs(ids ...int) {
	if m.removedfamily_members == nil {
		m.removedfamily_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.family_members, ids[i])
		m.removedfamily_members[ids[i]] = struct{}{}
	}
}

// RemovedFamilyMembers returns the removed IDs of the "family_members" edge to the User entity.
func (m *UserMutation) RemovedFamilyMembersIDs() (ids []int) {
	for id := range m.removedfamily_members {
		ids = append(ids, id)
	}
	return
}

// FamilyMembersIDs returns the "family_members" edge IDs in the mutation.
func (m *UserMutation) FamilyMembersIDs() (ids []int) {
	for id := range m.family_members {
		ids = append(ids, id)
	}
	return
}

// ResetFamilyMembers resets all changes to the "family_members" edge.
func (m *UserMutation) ResetFamilyMembers() {
	m.family_members = nil
	m.clearedfamily_members = false
	m.removedfamily_members = nil
}

// SetCredentialID sets the "credential" edge to the Credential entity by id.
func (m *UserMutation) SetCredentialID(id int) {
	m.credential = &id
}

// ClearCredential clears the "credential" edge to the Credential entity.
func (m *UserMutation) ClearCredential() {
	m.clearedcredential = true
}

// CredentialCleared reports if the "credential" edge to the Credential entity was cleared.
func (m *UserMutation) CredentialCleared() bool {
	return m.clearedcredential
}

// CredentialID returns the "credential" edge ID in the mutation.
func (m *UserMutation) CredentialID() (id int, exists bool) {
	if m.credential != nil {
		return *m.credential, true
	}
	return
}

// CredentialIDs returns the "credential" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CredentialID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CredentialIDs() (ids []int) {
	if id := m.credential; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCredential resets all changes to the "credential" edge.
func (m *UserMutation) ResetCredential() {
	m.credential = nil
	m.clearedcredential = false
}

// SetUsageModeID sets the "usage_mode" edge to the UsageMode entity by id.
func (m *UserMutation) SetUsageModeID(id int) {
	m.usage_mode = &id
}

// ClearUsageMode clears the "usage_mode" edge to the UsageMode entity.
func (m *UserMutation) ClearUsageMode() {
	m.clearedusage_mode = true
}

// UsageModeCleared reports if the "usage_mode" edge to the UsageMode entity was cleared.
func (m *UserMutation) UsageModeCleared() bool {
	return m.clearedusage_mode
}

// UsageModeID returns the "usage_mode" edge ID in the mutation.
func (m *UserMutation) UsageModeID() (id int, exists bool) {
	if m.usage_mode != nil {
		return *m.usage_mode, true
	}
	return
}

// UsageModeIDs returns the "usage_mode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsageModeID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UsageModeIDs() (ids []int) {
	if id := m.usage_mode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsageMode resets all changes to the "usage_mode" edge.
func (m *UserMutation) ResetUsageMode() {
	m.usage_mode = nil
	m.clearedusage_mode = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.mail != nil {
		fields = append(fields, user.FieldMail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldMail:
		return m.Mail()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldAddress:
		return m.Address()
	case user.FieldDescription:
		return m.Description()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldMail:
		return m.OldMail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAddress) {
		fields = append(fields, user.FieldAddress)
	}
	if m.FieldCleared(user.FieldDescription) {
		fields = append(fields, user.FieldDescription)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAddress:
		m.ClearAddress()
		return nil
	case user.FieldDescription:
		m.ClearDescription()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldMail:
		m.ResetMail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.visitor_gym != nil {
		edges = append(edges, user.EdgeVisitorGym)
	}
	if m.manager_gym != nil {
		edges = append(edges, user.EdgeManagerGym)
	}
	if m.personal_treiner != nil {
		edges = append(edges, user.EdgePersonalTreiner)
	}
	if m.owned_gyms != nil {
		edges = append(edges, user.EdgeOwnedGyms)
	}
	if m.abonements != nil {
		edges = append(edges, user.EdgeAbonements)
	}
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.manager_roles != nil {
		edges = append(edges, user.EdgeManagerRoles)
	}
	if m.family_of != nil {
		edges = append(edges, user.EdgeFamilyOf)
	}
	if m.family_members != nil {
		edges = append(edges, user.EdgeFamilyMembers)
	}
	if m.credential != nil {
		edges = append(edges, user.EdgeCredential)
	}
	if m.usage_mode != nil {
		edges = append(edges, user.EdgeUsageMode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVisitorGym:
		ids := make([]ent.Value, 0, len(m.visitor_gym))
		for id := range m.visitor_gym {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeManagerGym:
		ids := make([]ent.Value, 0, len(m.manager_gym))
		for id := range m.manager_gym {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePersonalTreiner:
		ids := make([]ent.Value, 0, len(m.personal_treiner))
		for id := range m.personal_treiner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedGyms:
		ids := make([]ent.Value, 0, len(m.owned_gyms))
		for id := range m.owned_gyms {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAbonements:
		ids := make([]ent.Value, 0, len(m.abonements))
		for id := range m.abonements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeManagerRoles:
		ids := make([]ent.Value, 0, len(m.manager_roles))
		for id := range m.manager_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFamilyOf:
		ids := make([]ent.Value, 0, len(m.family_of))
		for id := range m.family_of {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFamilyMembers:
		ids := make([]ent.Value, 0, len(m.family_members))
		for id := range m.family_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredential:
		if id := m.credential; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUsageMode:
		if id := m.usage_mode; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedvisitor_gym != nil {
		edges = append(edges, user.EdgeVisitorGym)
	}
	if m.removedmanager_gym != nil {
		edges = append(edges, user.EdgeManagerGym)
	}
	if m.removedpersonal_treiner != nil {
		edges = append(edges, user.EdgePersonalTreiner)
	}
	if m.removedowned_gyms != nil {
		edges = append(edges, user.EdgeOwnedGyms)
	}
	if m.removedabonements != nil {
		edges = append(edges, user.EdgeAbonements)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.removedmanager_roles != nil {
		edges = append(edges, user.EdgeManagerRoles)
	}
	if m.removedfamily_of != nil {
		edges = append(edges, user.EdgeFamilyOf)
	}
	if m.removedfamily_members != nil {
		edges = append(edges, user.EdgeFamilyMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVisitorGym:
		ids := make([]ent.Value, 0, len(m.removedvisitor_gym))
		for id := range m.removedvisitor_gym {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeManagerGym:
		ids := make([]ent.Value, 0, len(m.removedmanager_gym))
		for id := range m.removedmanager_gym {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePersonalTreiner:
		ids := make([]ent.Value, 0, len(m.removedpersonal_treiner))
		for id := range m.removedpersonal_treiner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedGyms:
		ids := make([]ent.Value, 0, len(m.removedowned_gyms))
		for id := range m.removedowned_gyms {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAbonements:
		ids := make([]ent.Value, 0, len(m.removedabonements))
		for id := range m.removedabonements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeManagerRoles:
		ids := make([]ent.Value, 0, len(m.removedmanager_roles))
		for id := range m.removedmanager_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFamilyOf:
		ids := make([]ent.Value, 0, len(m.removedfamily_of))
		for id := range m.removedfamily_of {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFamilyMembers:
		ids := make([]ent.Value, 0, len(m.removedfamily_members))
		for id := range m.removedfamily_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedvisitor_gym {
		edges = append(edges, user.EdgeVisitorGym)
	}
	if m.clearedmanager_gym {
		edges = append(edges, user.EdgeManagerGym)
	}
	if m.clearedpersonal_treiner {
		edges = append(edges, user.EdgePersonalTreiner)
	}
	if m.clearedowned_gyms {
		edges = append(edges, user.EdgeOwnedGyms)
	}
	if m.clearedabonements {
		edges = append(edges, user.EdgeAbonements)
	}
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.clearedmanager_roles {
		edges = append(edges, user.EdgeManagerRoles)
	}
	if m.clearedfamily_of {
		edges = append(edges, user.EdgeFamilyOf)
	}
	if m.clearedfamily_members {
		edges = append(edges, user.EdgeFamilyMembers)
	}
	if m.clearedcredential {
		edges = append(edges, user.EdgeCredential)
	}
	if m.clearedusage_mode {
		edges = append(edges, user.EdgeUsageMode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeVisitorGym:
		return m.clearedvisitor_gym
	case user.EdgeManagerGym:
		return m.clearedmanager_gym
	case user.EdgePersonalTreiner:
		return m.clearedpersonal_treiner
	case user.EdgeOwnedGyms:
		return m.clearedowned_gyms
	case user.EdgeAbonements:
		return m.clearedabonements
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	case user.EdgeManagerRoles:
		return m.clearedmanager_roles
	case user.EdgeFamilyOf:
		return m.clearedfamily_of
	case user.EdgeFamilyMembers:
		return m.clearedfamily_members
	case user.EdgeCredential:
		return m.clearedcredential
	case user.EdgeUsageMode:
		return m.clearedusage_mode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCredential:
		m.ClearCredential()
		return nil
	case user.EdgeUsageMode:
		m.ClearUsageMode()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeVisitorGym:
		m.ResetVisitorGym()
		return nil
	case user.EdgeManagerGym:
		m.ResetManagerGym()
		return nil
	case user.EdgePersonalTreiner:
		m.ResetPersonalTreiner()
		return nil
	case user.EdgeOwnedGyms:
		m.ResetOwnedGyms()
		return nil
	case user.EdgeAbonements:
		m.ResetAbonements()
		return nil
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case user.EdgeManagerRoles:
		m.ResetManagerRoles()
		return nil
	case user.EdgeFamilyOf:
		m.ResetFamilyOf()
		return nil
	case user.EdgeFamilyMembers:
		m.ResetFamilyMembers()
		return nil
	case user.EdgeCredential:
		m.ResetCredential()
		return nil
	case user.EdgeUsageMode:
		m.ResetUsageMode()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_role     *userrole.UserRole
	created_at    *time.Time
	updated_at    *time.Time
	is_close      *bool
	clearedFields map[string]struct{}
	gym           *int
	clearedgym    bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserRole sets the "user_role" field.
func (m *UserRoleMutation) SetUserRole(ur userrole.UserRole) {
	m.user_role = &ur
}

// UserRole returns the value of the "user_role" field in the mutation.
func (m *UserRoleMutation) UserRole() (r userrole.UserRole, exists bool) {
	v := m.user_role
	if v == nil {
		return
	}
	return *v, true
}

// OldUserRole returns the old "user_role" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserRole(ctx context.Context) (v userrole.UserRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserRole: %w", err)
	}
	return oldValue.UserRole, nil
}

// ResetUserRole resets all changes to the "user_role" field.
func (m *UserRoleMutation) ResetUserRole() {
	m.user_role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userrole.FieldUpdatedAt)
}

// SetIsClose sets the "is_close" field.
func (m *UserRoleMutation) SetIsClose(b bool) {
	m.is_close = &b
}

// IsClose returns the value of the "is_close" field in the mutation.
func (m *UserRoleMutation) IsClose() (r bool, exists bool) {
	v := m.is_close
	if v == nil {
		return
	}
	return *v, true
}

// OldIsClose returns the old "is_close" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldIsClose(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsClose: %w", err)
	}
	return oldValue.IsClose, nil
}

// ResetIsClose resets all changes to the "is_close" field.
func (m *UserRoleMutation) ResetIsClose() {
	m.is_close = nil
}

// SetGymID sets the "gym" edge to the Gym entity by id.
func (m *UserRoleMutation) SetGymID(id int) {
	m.gym = &id
}

// ClearGym clears the "gym" edge to the Gym entity.
func (m *UserRoleMutation) ClearGym() {
	m.clearedgym = true
}

// GymCleared reports if the "gym" edge to the Gym entity was cleared.
func (m *UserRoleMutation) GymCleared() bool {
	return m.clearedgym
}

// GymID returns the "gym" edge ID in the mutation.
func (m *UserRoleMutation) GymID() (id int, exists bool) {
	if m.gym != nil {
		return *m.gym, true
	}
	return
}

// GymIDs returns the "gym" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GymID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) GymIDs() (ids []int) {
	if id := m.gym; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGym resets all changes to the "gym" edge.
func (m *UserRoleMutation) ResetGym() {
	m.gym = nil
	m.clearedgym = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserRoleMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserRoleMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_role != nil {
		fields = append(fields, userrole.FieldUserRole)
	}
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.is_close != nil {
		fields = append(fields, userrole.FieldIsClose)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUserRole:
		return m.UserRole()
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case userrole.FieldIsClose:
		return m.IsClose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldUserRole:
		return m.OldUserRole(ctx)
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userrole.FieldIsClose:
		return m.OldIsClose(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUserRole:
		v, ok := value.(userrole.UserRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserRole(v)
		return nil
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userrole.FieldIsClose:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsClose(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldUpdatedAt) {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUserRole:
		m.ResetUserRole()
		return nil
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userrole.FieldIsClose:
		m.ResetIsClose()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.gym != nil {
		edges = append(edges, userrole.EdgeGym)
	}
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeGym:
		if id := m.gym; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgym {
		edges = append(edges, userrole.EdgeGym)
	}
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeGym:
		return m.clearedgym
	case userrole.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeGym:
		m.ClearGym()
		return nil
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeGym:
		m.ResetGym()
		return nil
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
